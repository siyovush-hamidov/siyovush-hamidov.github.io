<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Uniswap V2 Complete Code Walkthrough
        
    </title><meta content="Uniswap V2 Complete Code Walkthrough" property=og:title><meta content="Blockchain Security Researcher" property=og:description><meta content="Blockchain Security Researcher" name=description><link href=/favicons/favicon.ico rel=icon type=image/png><link href=https://siyovush-hamidov.github.io/fonts.css rel=stylesheet><script src=https://siyovush-hamidov.github.io/js/codeblock.js></script><script src=https://siyovush-hamidov.github.io/js/toc.js></script><script src=https://siyovush-hamidov.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Siyovush Hamidov" href=https://siyovush-hamidov.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://siyovush-hamidov.github.io/theme/light.css rel=stylesheet><link href=https://siyovush-hamidov.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://siyovush-hamidov.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://siyovush-hamidov.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://siyovush-hamidov.github.io>Siyovush Hamidov</a><div class=socials><a class=social href=https://x.com/HamidovSiyovush/ rel=me target=_blank> <img alt=twitter src=https://siyovush-hamidov.github.io/social_icons/twitter.svg> </a><a class=social href=https://www.linkedin.com/in/siyovush-hamidov/ rel=me target=_blank> <img alt=linkedin src=https://siyovush-hamidov.github.io/social_icons/linkedin.svg> </a><a class=social href=https://github.com/siyovush-hamidov/ rel=me target=_blank> <img alt=github src=https://siyovush-hamidov.github.io/social_icons/github.svg> </a><a href="mailto: siyovushchik14@gmail.com" class=social rel=me target=_blank> <img alt=Email src=https://siyovush-hamidov.github.io/social_icons/email.svg> </a></div></div><nav><a href=https://siyovush-hamidov.github.io/writeups style=margin-left:.5em>/writeups</a><a href=https://siyovush-hamidov.github.io/projects style=margin-left:.5em>/projects</a><a href=https://siyovush-hamidov.github.io/contact style=margin-left:.5em>/contact</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://siyovush-hamidov.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://siyovush-hamidov.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Uniswap V2 Complete Code Walkthrough<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-01-09</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://siyovush-hamidov.github.io/tags/web3/>web3</a>, <a class=post-tag href=https://siyovush-hamidov.github.io/tags/defi/>defi</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-1-erc4626-vaults>Chapter-1 : ERC4626 Vaults</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#methods>Methods</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#events>Events</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#slippage>Slippage</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#erc4626-inflation-attack>ERC4626 inflation attack</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#example-implementation-of-share-asset-calculation>Example Implementation of share/asset calculation</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-2-erc3156-flash-loans>Chapter-2 : ERC3156 Flash Loans</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#what-are-flashloans-used-for>What are flashloans used for?</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#erc3156-protocol>ERC3156 Protocol</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#erc3156-receiver-specification>ERC3156 Receiver Specification</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#erc3156-lender-specification>ERC3156 Lender Specification</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#security-considerations>Security Considerations</a></ul></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-3-uniswap-v2-architecture>Chapter-3 :Uniswap V2 Architecture</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#how-amm-works>How AMM works?</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#advantages-of-amms>Advantages of AMMs</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#disadvantages-of-amms>Disadvantages of AMMs</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#architecture-of-uniswap-v2>Architecture of Uniswap V2</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-4-uniswap-v2-swap-function>Chapter - 4 :Uniswap V2 Swap Function</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#flash-borrowing>Flash Borrowing</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#swap>Swap</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#measuring-the-amount-of-incoming-tokens>Measuring the amount of incoming tokens</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#balancing-xy-k>Balancing XY = K</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#updating-reserves>Updating Reserves</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#safety-checks-in-swap>Safety Checks in Swap</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-5-mint-and-burn-functions>Chapter - 5 : Mint and Burn Functions</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswap-v2-burn>Uniswap V2 Burn</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#safety-checks-in-burn>Safety checks in burn</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswap-v2-mint>Uniswap V2 Mint</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#minting-liquidity-when-the-pool-is-not-empty>Minting liquidity when the pool is not empty</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#minting-liquidity-when-the-pool-is-empty-first-minting>Minting liquidity when the pool is empty (First Minting)</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#why-uniswap-calculates-liquidity-as-square-root-k>Why Uniswap Calculates Liquidity as Square Root K</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#fees>Fees</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-6-protocol-mint-fee>Chapter - 6 : Protocol Mint Fee</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#computing-the-mintfee-assumptions>Computing the mintFee assumptions</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#calculation-of-mintfee>Calculation of mintFee</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#where-klast-gets-updated>Where klast gets updated</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#explaination>Explaination</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-7-twap-oracle>Chapter - 7 : TWAP Oracle</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#price-is-a-ratio>Price is a ratio</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#oracle-definition>Oracle definition</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#motivation-behind-twap>Motivation behind TWAP</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#how-twap-works>How TWAP works</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswap-v2-does-not-store-lookback-or-the-denominator>Uniswap V2 does not store lookback or the denominator</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#limiting-the-lookback-window>Limiting the lookback window</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#only-calculating-the-last-1-hour-twap-in-solidity>Only calculating the last 1 hour TWAP in Solidity</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#what-if-the-last-snapshot-is-over-three-hours-ago>What if the last snapshot is over three hours ago?</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#why-twap-must-track-two-ratios>Why TWAP must track two ratios</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#pricecumulativelast-always-increases-until-it-overflows-then-keeps-going>PriceCumulativeLast always increases until it overflows, then keeps going</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#overflowing-the-timestamp>Overflowing the timestamp</a></ul></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-8-uniswapv2library>Chapter - 8 : UniswapV2Library</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#using-uniswapv2library>Using UniswapV2Library</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#getamountout>getAmountOut()</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#getamountin>getAmountIn()</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#pairfor-and-sorttokens>pairFor() and sortTokens()</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#getamountsout>getAmountsOut</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#getamountsin>getAmountsIn</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#getreserves>getReserves()</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#quote>quote()</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-9-routers>Chapter - 9 : Routers</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswapv2router01>UniswapV2Router01</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#swapexacttokensfortokens>swapExactTokensForTokens()</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#swaptokensforexacttokens>swapTokensForExactTokens()</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#which-swap-function-to-use>Which swap function to use?</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#how-swap-works>How swap works?</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#the-swap-function>The _swap() function</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#swapexactethfortokens>swapExactETHForTokens</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#swaptokensforexacteth>swapTokensForExactETH</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#swapexacttokensforeth>swapExactTokensForETH</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#swapethforexacttokens>swapETHForExactTokens</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#addliquidity>_addLiquidity</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#addliquidity-and-addliquidityeth>addLiquidity() and addLiquidityEth()</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#removing-liquidity>Removing Liquidity</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#removeliquiditywithpermit-and-removeliquidityethwithpermit>removeLiquidityWithPermit() and removeLiquidityETHWithPermit()</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswapv2router02>UniswapV2Router02</a></li><ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#wrappers-around-the-uniswapv2library>Wrappers around the UniswapV2Library</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#summary>Summary</a></ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#chapter-10-misc>Chapter - 10 : MISC</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswapv2factory-sol>UniswapV2Factory.sol</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswapv2migrator-sol>UniswapV2Migrator.sol</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswapv2erc20-sol>UniswapV2ERC20.sol</a><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#uniswapv2pair-sol-sync-and-skim>UniswapV2Pair.sol : sync() and skim()</a> <ul><li><a href=https://siyovush-hamidov.github.io/posts/uniswapv2-complete/#references>References</a></ul></ul></div><section class=body><p>Hello all, This post is all about <strong>Uniswap V2 Contracts</strong>. This is the notes written by me while learning Uniswap V2 from various resources. I have written short notes on each and every line of code in <a href=https://github.com/Uniswap/v2-core/ target=_blank>UniswapV2 Core Contracts</a> and <a href=https://github.com/Uniswap/v2-periphery/ target=_blank>UniswapV2 Periphery Contracts</a>. You can check my <a href=https://themj0ln1r.github.io/posts/uniswapv2overview>Uniswap V1_V2_V3 Overview</a> post to get a an overview on Uniswap protocol.<p>I have used many resources to learn about UniswapV2. This notes aggregates <a href=https://www.rareskills.io/uniswap-v2-book target=_blank>Rareskills UniswapV2 Book</a>, <a href=https://twitter.com/0xOwenThurm/status/1662805937575596034 target=_blank>@0xOwneThurm</a>, <a href=https://twitter.com/ProgrammerSmart target=_blank>@ProgrammerSmart</a>, <a href=https://twitter.com/Younsle1 target=_blank>@Zer0luck.eth</a>, <a href=https://twitter.com/officer_cia target=_blank>@officer_cia</a> and few the great anons.<p><strong>I am very grateful to all these legends for the knowledge</strong><h1 id=chapter-1-erc4626-vaults><a aria-label="Anchor link for: chapter-1-erc4626-vaults" class=zola-anchor href=#chapter-1-erc4626-vaults><strong>Chapter-1 : ERC4626 Vaults</strong></a></h1><p>ERC4626 is a tokenized vault standard that uses ERC20 tokens to represent shares of some other asset.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_1.png><p>When an ERC4626 contract gives you an ERC20 token for the initial deposit, it gives you token S (an ERC20 compliant token). ERC4626 contract is also <strong>ERC20</strong> token.<p>The ERC4626 extends the ERC20 contract and during construction phase, it takes as an argument the other ERC20 token users will be depositing to it. Therefore, ERC4626 supports all the functions and events you expect from ERC20. The token of ERC4626 contract is referred to <strong>shares</strong>.<p>Each ERC4626 contract only supports <strong>one asset</strong>. You cannot deposit multiple kinds of ERC20 tokens into the contract and get shares back.<p><strong>Why ERC4626 ?</strong><p>Let’s say we all own a company, or a liquidity pool, that earns a stablecoin DAI periodically. The stablecoin DAI is the asset in this case.<p>One inefficient way we could distribute the earnings is to push out DAI to each of the holders of the company on a pro-rata basis. But this would be extremely expensive gas wise.<p>Instead, this is how the workflow would work with ERC4626.<p>Let’s say you and ten friends get together and each deposit 10 DAI each into the ERC4626 vault. You get back one share.<p>So far so good. Now your company earns 10 more DAI, so the total DAI inside the vault is now 110 DAI.<p>When you trade your share back for your part of the DAI, you don’t get 10 DAI back, but 11.<p>Now there is 99 DAI in the vault, but 9 people to share it among. If they were to each withdraw, they would get 11 DAI each.<p>Note how efficient this is. When someone makes a trade, instead of updating everyones shares one-by-one, only the total supply of shares and the amount of assets in the contract changes.<h3 id=methods><a aria-label="Anchor link for: methods" class=zola-anchor href=#methods><strong>Methods</strong></a></h3><p><a href=https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/>https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/</a><p><strong>Giving assets, getting shares: deposit() and mint()</strong><p>According to the EIP, the user is depositing assets and getting shares back, so what's the difference between these two functions?<ul><li>With <em>deposit()</em>, you <strong>specify how many assets</strong> you want to put in, and the function will calculate how many shares to send to you.<li>With <em>mint()</em>, you <strong>specify how many shares</strong> you want, and the function will calculate how much of the ERC20 asset to transfer from you.</ul><p>Of course, if you don’t have enough assets to transfer in to the contract, the transaction will revert.<p>The uint256 that gets returned to you is <strong>amount of shares</strong> you get back.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_2.png><p><strong>Anticipating how many shares you will get</strong><ul><li>previewDeposit<li>previewMint</ul><p>Like their state changing counterparts, previewDeposit takes assets as an argument and previewMint takes shares as an argument.<p><strong>Anticipating how many shares you will get under ideal conditions</strong><p>Confusingly enough, there is also a view function called <strong>convertToShares</strong> which takes assets as an argument and returns the amount of shares you will get back under ideal conditions (no slippage or fees).<p>Why would you care about this ideal information that doesn’t reflect the trade you will execute?<p>The difference between ideal and actual results tells you how much your trade is impacting the market and how the fee depends on trade size. A smart contract could do a binary search on the difference between convertToShares and previewMint to find the best trade size to execute.<p><strong>Returning shares, getting assets back</strong> The inverse of <strong>deposit</strong> and <strong>mint</strong> is <strong>withdraw</strong> and <strong>redeem</strong> respectively.<p><strong>withdraw</strong> lets you specify how many <strong>assets</strong> you want to take from the contract, and the contract calculates how many of your shares to burn.<p><code>function withdraw(uint256 assets, address receiver, address owner) public returns (uint256 shares)</code><p><strong>redeem</strong>, you specify how many shares you want to <strong>burn</strong>, and the contract calculates the amount of assets to give back.<p><code>function redeem(uint256 shares, address receiver, address owner) public returns (uint256 assets)</code><p><strong>Anticipating how many shares you will burn to get assets back</strong><p>The view methods for withdraw and redeem are <strong>previewRedeem</strong> and <strong>previewWithdraw</strong> respectively.<p>The <strong>idealized</strong> analog of these functions is <strong>convertToAssets</strong> which takes shares as an argument and gives you how many assets you will get back, not including fees and slippage.<p><strong>Summary of functions :</strong>*</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_3.png><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_4.png><p>The functions mint, deposit, redeem, and withdraw, have an second argument “receiver” for cases where the account receiving shares or assets from the ERC4626 is not msg.sender. This means I can deposit assets into the account and specify that the ERC4626 contract give you the shares.<p>Redeem and withdraw have a third argument, “owner” which allows msg.sender to burn the shares of the “owner” while sending assets to the “receiver” (second argument) if they have allowance to do so.<p><strong>maxDeposit, maxMint, maxWithdraw, maxRedeem</strong> These functions take identical arguments to their state-changing counterparts and return the largest trade they can execute. This can change per address (remember, we just discussed that these functions take addresses as arguments).<h3 id=events><a aria-label="Anchor link for: events" class=zola-anchor href=#events>Events</a></h3><p>ERC4626 has only two events in addition to the <strong>ERC20 events</strong> it inherits: <strong>Deposit</strong> and <strong>Withdraw</strong>. These are also emitted if mint and redeem were called, because functionally the same thing happened: tokens were swapped.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>event Deposit(
</span><span>    address indexed sender,
</span><span>    address indexed owner,
</span><span>    uint256 assets,
</span><span>    uint256 shares
</span><span>)
</span><span>event Withdraw(
</span><span>    address indexed sender,
</span><span>    address indexed receiver,
</span><span>    address indexed owner,
</span><span>    uint256 assets,
</span><span>    uint256 share
</span><span>)
</span></code></pre><h3 id=slippage><a aria-label="Anchor link for: slippage" class=zola-anchor href=#slippage>Slippage</a></h3><p><em><strong>Any token swapping protocol has an issue where the user might not get back the amount of tokens they were expecting.</strong></em><p>For example, with automated market makers, a large trade might use up the liquidity and cause the price to move substantially.<p><em><strong>Another issue is a transaction getting frontrun or experiencing a sandwich attack. In the examples above, we've assumed the ERC4626 contract maintains a one-to-one relationship between asset and shares regardless of the supply, but the ERC4626 standard does not dictate how the pricing algorithm should work.</strong></em><p>For example, suppose we make the amount of shares issued a function of the square root of the assets deposited. In that case, whoever deposits first will get a larger amount of shares. This could encourage opportunistic traders to frontrun deposit orders and force the next buyer to pay a larger amount of the asset for the same amount of shares.<p>The defense against this is simple: the contract interacting with an ERC4626 should measure the amount of shares it received during a deposit (and assets during a withdraw) and revert if it does not receive the quantity expected within a certain slippage tolerance.<p>This is a standard design pattern to deal with slippage issues. It will also defend against the issue described below.<h3 id=erc4626-inflation-attack><a aria-label="Anchor link for: erc4626-inflation-attack" class=zola-anchor href=#erc4626-inflation-attack><strong>ERC4626 inflation attack</strong></a></h3><p>Although ERC4626 is agnostic to the algorithm that translates prices to shares, most implementations use a linear relationship. If there are 10,000 assets, and 100 shares, then 100 assets should result in 1 share.<p>But what happens if someone sends 99 assets? It will round down to zero and they get zero shares.<p>Of course no-one would intentionally throw away their money like this. However, an attacker can frontrun a trade by donating assets to the vault.<p>If an attacker donates money to the vault, one share is suddenly worth more than it was initially. If there are 10,000 assets in the vault corresponding to 100 shares, and the attacker donates 20,000 assets, then one share is suddenly worth 300 assets instead of 100 assets. When the victim’s trade trades in assets to get back shares, they suddenly get a lot fewer shares — possibly zero.<p>There are three <strong>defenses</strong>:<ul><li>Revert if the amount received is not within a slippage tolerance (described earlier)<li>The deployer should deposit enough assets into the pool such that doing this inflation attack would be too expensive<li>Add "virtual liquidity" to the vault so the pricing behaves as if the pool had been deployed with enough assets.</ul><p>Here is OpenZeppelin's implementation of <strong>virtual liquidity</strong>:</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_5.png><p>When calculating the amount of shares a depositor receives, the total supply is artificially inflated (at a rate the programmer specifies in _decimalsOffset()).<p>Let's walk through an example. By way of reminder, here is what the variables above mean:<ul><li>totalSupply() = total number of shares issued<li>totalAssets() = the balance of assets held by the ERC4626<li>assets = the amount of assets the user is depositing</ul><p>The formula is<p><code>shares_received = assets_deposited * totalSupply() / totalAssets();</code><p>There is some implementation details for rounding in favor of the pool and adding 1 to totalAssets() to ensure we don't divide by zero if the pool is empty.<p>Let's say we have the following numbers:<p>assets_deposited = 1,000<p>totalSupply() = 1,000<p>totalAssets() = 999,999 (the formula adds 1, so we will set it this way to make the number nice)<p>In that case, the shares the user will get is 1,000 x 1,000 ÷ 1,000,000, or exactly 1.<p>This is obviously very fragile. If the attacker frontruns the deposit of 1,000 shares and deposits assets, then the victim will get zero back, because 1 million divided by a number larger than 1 million is zero in integer division.<p><strong>How does virtual liquidity solve this?</strong> Using the code from the screenshot above, we would set _decimalOffset() to be 3, so that way totalSupply() gets 1,000 added to it.<p>Effectively, we are making the numerator 1,000 times larger. This forces the attacker to make a donation 1,000 times as large, which disincentivizes them from conducting the attack.<p><strong>Example of inflation attack</strong><ol><li>When a depositor wants to be the initial depositor, sends 10 USDC to the vault.<li>Attacker see’s that tx and front runs with calling deposit with 1 USDC. So, now the attacker becomes the initial depositor and totalSupply becomes 1. Attacker receives 1 share.<li>And now attacker donates equal amount of USDC that user transfer to the vault without calling the deposit function. So, the totalSupply won’t be updated. totalSupply still 1. And the totalBalance becomes 10 USDC.<li>Now the else block of the deposit executes and number of shares that mints to the user becomes 0.<li>So, the shares are that minted are only to attacker. So attacker owns the whole ownership on vault. Attacker can withdraw all the balance in the vault now.</ol><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_6.png><h3 id=example-implementation-of-share-asset-calculation><a aria-label="Anchor link for: example-implementation-of-share-asset-calculation" class=zola-anchor href=#example-implementation-of-share-asset-calculation>Example Implementation of share/asset calculation</a></h3><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_7.png><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter1_8.png><p><strong>Real life examples of share / asset accounting</strong><p>Earlier versions of <strong>Compound</strong> minted what they called <strong>c-tokens</strong> to users who supplied liquidity. For example, if you deposited USDC, you would get a separate cUSDC (Compound USDC) back. When you decided to stop lending, you would send back your cUSDC to compound (where it would be burned) then get your pro-rata share of the USDC lending pool.<p><strong>Uniswap</strong> used <strong>LP tokens</strong> as “shares” to represent how much liquidity someone had put into a pool, (and how much they could withdraw pro-rata) when they redeemed the LP tokens for the underlying asset.<h1 id=chapter-2-erc3156-flash-loans><a aria-label="Anchor link for: chapter-2-erc3156-flash-loans" class=zola-anchor href=#chapter-2-erc3156-flash-loans><strong>Chapter-2 : ERC3156 Flash Loans</strong></a></h1><p><strong>Flash Loans and how to hack them: a walk through of ERC 3156</strong><p><em><strong>Flash loans</strong> are loans between smart contracts that must be repaid in the same transaction.</em><p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Simple Flash Loan :</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter2_1.webp><p>If the borrower does not pay back the loan, therequire statement with the message “flash not paid back” will cause the entire transaction to revert.<ul><li><strong>Only contracts can work with flash loans</strong><li><strong>No need of collateral to take flash loan</strong></ul><h3 id=what-are-flashloans-used-for><a aria-label="Anchor link for: what-are-flashloans-used-for" class=zola-anchor href=#what-are-flashloans-used-for><strong>What are flashloans used for?</strong></a></h3><p><strong>Arbitrage</strong> : The most common use case for a flash loan is to do an arbitrage trade.<p><strong>Refinancing Loans</strong><p>For regular DeFi loans, they typically require some kind of collateral. For example, if you were borrowing $10,000 in stable coins, you would need to deposit $15,000 of Ether as collateral.<p>If your stable coins loan had a 5% interest and you wanted to refinance with another lending smart contract at 4%, you would need to<ol><li>pay back the $10,000 in stable coins<li>withdraw the $15,000 Ether collateral<li>deposit the $15,000 Ether collateral into the other protocol<li>borrow $10,000 in stable coins again at the lower rate</ol><p>This would be problematic if you had the $10,000 tied up in some other application. With a flashloan, you can do steps 1-4 without using any of your own stable coins.<p><strong>Exchanging collateral</strong><p>In the example above, the borrower was using $15,000 of Ether as collateral. But suppose the protocol is offering a lower collateralization ratio using wBTC (wrapped bitcoin)? The borrower could use a flash loan and a similar set of steps outline above to swap out the collateral instead of the principal.<p><strong>Liquidating Borrowers</strong><p>In the context of DeFi loans, if the collateral falls below a certain threshold, then the collateral can get liquidated — forcibly sold to cover the cost of the loan. In the example above, if the value of the Ether was to drop to $12,000, then the protocol might allow someone to purchase the Ether for $11,500 if they first pay back the $10,000 loan.<p>A liquidator could use a flash loan to pay off the $10,000 stable coin loan and receive $11,500. They would then sell this on another exchange for stable coins, and then pay back the flash loan.<p><strong>Increase yield for other DeFi applications</strong><p>Uniswap and AAVE earn depositors’ money through trading fees or lending interest. But since they have such a large amount of capital in one place, they can make additional money by also offering flash loans. This increases the efficiency of capital since the same capital now has more uses.<p><strong>Hacking Smart Contracts</strong><p>Flash loans are probably most famous for their use by black hat hackers to exploit protocols. The primary attack vectors for flash loans are price manipulation and governance (vote) manipulation. Used on DeFi applications with inadequate defense, flash loans allow attackers to heavily buy up an asset increasing its price, or acquiring a bunch of voting tokens to push through a governance proposal.<p>The following is a list of flash loan hacks for the curious. Vulnerability is two-sided however. A flash lending and flash borrowing contract can also be vulnerable to losing money if not implemented properly.<h2 id=erc3156-protocol><a aria-label="Anchor link for: erc3156-protocol" class=zola-anchor href=#erc3156-protocol><strong>ERC3156 Protocol</strong></a></h2><p><em><strong>ERC3156 seeks to standardize the interface for getting flash loans.</strong></em><h3 id=erc3156-receiver-specification><a aria-label="Anchor link for: erc3156-receiver-specification" class=zola-anchor href=#erc3156-receiver-specification><strong>ERC3156 Receiver Specification</strong></a></h3><p>The first aspect of the standard is the interface the borrower needs to implement, which is shown below. The borrower only needs to implement one function.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter2_2.webp><p><strong>initiator</strong><p>This is the address that initiated the flash loan. <strong>You probably want some kind of validation here so that untrusted addresses are not initiating flashloans on your contract.</strong> Usually, the address would be <em><strong>you</strong></em>, but you shouldn’t assume that!<p>The function onFlashLoan is <strong>expected</strong> to be called by the flash loan contract, not the initiator. <strong>You should check msg.sender is the flash loan contract inside the onFlashLoan() function because this function is external and anyone can call it.</strong><p><strong>Initiator is not msg.sender or the flash loan contract. It is the address that triggered the flash lending contract to call the receiver’s onFlashLoan function.</strong><p><strong>token</strong><p>This is the address of the ERC20 token you are borrowing. Contracts offering flash loans will usually hold several tokens they can flash loan out. The ERC3156 flash loan standard does not support flash loaning native Ether, but this can be implemented by flash loaning WETH and having the borrower unwrap the WETH. Because the borrowing contract is not necessarily the contract that called the flash loaner, the borrowing contract may need to be told what token is being flash lent.<p><strong>fee</strong><p>Fee is how much of the token needs to be paid as a fee for the loan. It is denominated in absolute amount, not percentages.<p><strong>data</strong><p>If your flash loan receiving contract isn’t hard coded to take a particular action when receiving a flash loan, you can parameterize its behavior with the data parameter. For example, if your contract is arbitraging trading pools, then you would specify which pools to trade with.<p><strong>return value</strong><p>The contract must return <code>keccak256("ERC3156FlashBorrower.onFlashLoan")</code><p><strong>Reference implementation of the borrower</strong><p><strong>If the flash lender were somehow compromised, the contract below could be exploited through feeding it bogus amount and fee and initiator data.</strong> If the lender is immutable, this isn’t a concern, but it could be an attack vector if the lender is upgradeable.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter2_3.webp><h3 id=erc3156-lender-specification><a aria-label="Anchor link for: erc3156-lender-specification" class=zola-anchor href=#erc3156-lender-specification><strong>ERC3156 Lender Specification</strong></a></h3><p>Below is the interface for the lender specified by ERC3156</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter2_4.webp><p>The <code>flashLoan()</code> function needs to accomplish a few important operations:<ul><li>Someone might call <code>flashLoan()</code> with a token the flash loan contract does not support. This should be checked for.<li>Someone might call <code>flashLoan()</code> with an amount that is larger than <code>maxFlashLoan</code>. This also should be checked for<li><code>data</code> is simply forwarded to the caller.</ul><p>More importantly, <code>flashLoan()</code> must transfer the tokens to the receiver <em><strong>and</strong></em> transfer them back. It should not rely on the borrower transferring the tokens back for repayment.<p><strong>Reference Implementation of Lender</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter2_5.webp><p>Note that the reference implementation is assuming that the ERC20 tokens return true on success, which not all do, so use the SafeTransfer library if using non-compliant ERC20 tokens.<h3 id=security-considerations><a aria-label="Anchor link for: security-considerations" class=zola-anchor href=#security-considerations><strong>Security Considerations</strong></a></h3><p><strong>Access control and input validation for borrower</strong><p>The borrowing smart contract must have the controls in place to only allow the flash lender contract to be the caller of <code>onFlashLoan()</code>. Otherwise, some actor other than the flash lender can call <code>onFlashLoan()</code> and cause unexpected behavior.<p>Furthermore, <em><strong>anyone can call flashloan()</strong></em> with an arbitrary borrower as the target and pass arbitrary data. To ensure the data is not malicious, a flash loan receiver contract should only allow a restricted set of initiators.<p><strong>Reentrance locks are very important</strong><p>ERC 3156 by definition cannot follow the check effects pattern to prevent reentrancy. It has to notify the borrower it has received the tokens (make an external call), then transfer the tokens back. As such, <code>nonReentrant</code> locks should be added to the contract.<p><strong>It is important that the lender is the one transferring the tokens back or that reentrancy locks are in place.</strong><p>In the above implementations, the lender transfers the tokens back from the borrower. The borrower does not transfer the loans to the lender. This is important to avoid “<strong>side entrances</strong>” where the borrower deposits money into the protocol as a lender. Now the pool sees it’s balance has returned to what it was before, but the borrower suddenly has become a lender with a large deposit.<p>UniswapV2’s flash loan does not transfer the tokens back after the flash loan finishes. However, it uses a reentrancy lock to ensure that the borrower cannot “pay back the loan” by depositing it back into the protocol as if they were a lender.<p><strong>For the borrower, ensure only flash lender contract can call onFlashLoan</strong><p>The flash lender is hardcoded to only call the receiver’s <code>onFlashLoan()</code> function and nothing else. If a borrower had a way to specify which function the flash lender would call, then the flash loan could be manipulated into transferring other tokens in it’s possession (by calling ERC20.transfer) or granting approval to it’s token balance to a malicious address.<p>Because such actions require an explicit call to an ERC20 transfer or approve, this can’t happen if the flash lender can only call <code>onFlashLoan()</code>.<p><strong>Using token.balanceOf(address(this)) can be manipulated</strong><p>In the implementation above, we do not use balanceOf(address(this)) except to determine the maximum flash loan size. This can be altered by someone else directly transferring tokens to the contract, interfering with the logic. The way we know the flash loan was paid back is because the lender transferred back the loan amount + fee. There are valid ways to use balanceOf(address(this)) to check repayment, but this must be combined with reentrancy checks to avoid paying back the loan as a deposit.<p><strong>Why the flash borrower needs to return keccak256("ERC3156FlashBorrower.onFlashLoan");</strong><p>This handles the situation where a contract (not the flash lender contract) with a fallback function has given approval to the flash lending contract. Someone could repeatedly initiate a flashloan with that contract as a recipient. Then the following would happen:<ol><li>The victim contract gets a flashloan<li>The victim contract gets called with <code>onFlashLoan()</code> and the fallback function is triggered but does not revert. The fallback function responds to any function call that doesn't match the rest of the functions in the contract, so it will respond to a <code>onFlashLoan()</code> call.<li>The flash lender withdraws tokens from the borrower + fee</ol><p>If this operation happens in a loop, the victim contract with the fallback will get drained. The same could happen with an EOA wallet, since calling a wallet address with <code>onFlashLoan</code> does not revert.<p>Checking that the <code>onFlashLoan</code> function does not revert isn’t good enough. The flash lender also checks that the value <code>keccack256("ERC3156FlashBorrower.onFlashLoan")</code> is returned so that it knows the borrower intended to borrow the tokens and also pay back the fee.<h1 id=chapter-3-uniswap-v2-architecture><a aria-label="Anchor link for: chapter-3-uniswap-v2-architecture" class=zola-anchor href=#chapter-3-uniswap-v2-architecture><strong>Chapter-3 :Uniswap V2 Architecture</strong></a></h1><p><strong>Uniswap V2 Architecture: An Introduction to Automated Market Makers</strong><p>Uniswap is a DeFi app that enables traders to swap one token for another in a trustless manner. It was one of the early automated market makers for trading (though not the first).<p><strong>Automated market makers</strong> are an alternative to an order book, which the reader is assumed to already be familiar with.<h3 id=how-amm-works><a aria-label="Anchor link for: how-amm-works" class=zola-anchor href=#how-amm-works>How AMM works?</a></h3><p><a href="https://www.notion.so/AMM-b765f5f5aa484cd0a6651a3203b93be3?pvs=21">AMM</a><p>An automated market maker holds two tokens (token X and token Y) in the pool (a smart contract). It allows anyone to withdraw token X from the pool, but they must deposit an amount of token Y such that the ”total” of assets in the pool does not decrease, where we consider the “total” to be the product of the amounts of the two assets.<p>Assets are provided to the pool by <em><strong>liquidity providers</strong></em>, who receive so-called <strong>LP tokens</strong> to represent their share of the pool. Liquidity provider balances are tracked in a manner similar to how <a href=https://www.rareskills.io/post/erc4626>ERC 4626</a> works. The difference between an AMM and ERC 4626 is that ERC 4626 only supports one asset but an AMM has two tokens. Just like a vault, the liquidity providers’ share of the pool stays the same, but the product X*Y gets larger, so their slice is larger.<h3 id=advantages-of-amms><a aria-label="Anchor link for: advantages-of-amms" class=zola-anchor href=#advantages-of-amms>Advantages of AMMs</a></h3><p><strong>AMMs do not have a bid-ask spread</strong><p>In an AMM, price discovery is automatic. It’s determined by the ratio of assets in the pool.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter3_1.webp><p>There is no need to wait for a suitable “bid” or “ask” order to show up. It always exists.<p>If there is a mismatch between the price in an AMM and another exchange, then a trader will <strong>arbitrage</strong> the difference, bringing the prices back into balance.<p><strong>AMMs doubled as an oracle</strong><p>Since the price of the assets is automatically determined, other smart contracts can use an AMM as a price oracle. However, AMM prices can be manipulated with flash loans, so safeguards need to be put in place when using AMMs in this manner. Nonetheless, it is valuable that price data is provided for free.<p><strong>AMMs are highly gas efficient compared to order books</strong><p>Order books requires a significant amount of bookkeeping (no pun intended). An AMM only needs to hold two tokens and transfer them according to simple rules. This makes them more efficient to implement.<h3 id=disadvantages-of-amms><a aria-label="Anchor link for: disadvantages-of-amms" class=zola-anchor href=#disadvantages-of-amms>Disadvantages of AMMs</a></h3><p>There are two major drawbacks to automated market makers: 1) the price always moves and 2) impermanent loss for liquidity providers.<p><strong>Even small orders move the price in AMMs</strong><p>A buy or sell order will generally encounter more <strong>slippage</strong> than in an order book model, and the mechanism of swapping invites sandwich attacks.<p><strong>Sandwich attacks are largely unavoidable in AMMs</strong><ol><li><p>Attacker’s first buy (front run): drives up price for victim</p><li><p>Victim’s buy: drive up price even further</p><li><p>Attacker’s sell: sell the first buy at a profit</p></ol><p><strong>Liquidity providers don’t have control over the price their assets are sold at</strong><p>Liquidity providers can only provide assets proportional to the current ratio of tokens in the pool.<p><strong>Liquidity providers for AMMs may suffer from impermanent Loss</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter3_2.webp><p>The missed out on gains are called “<strong>impermanent loss</strong>.” In the table above, the impermanent loss is $810 = ($990 - $180).<h1 id=architecture-of-uniswap-v2><a aria-label="Anchor link for: architecture-of-uniswap-v2" class=zola-anchor href=#architecture-of-uniswap-v2>Architecture of Uniswap V2</a></h1><p>The architecture of Uniswap V2 is surprisingly simple. At its core is the <strong>UniswapV2Pair</strong> contract that holds two ERC 20 tokens that traders can swap against, or liquidity providers can provide liquidity for. Every different possible <strong>UniswapV2Pair</strong> has a different UniswapV2Pair contract to manage it. If the desired <strong>UniswapV2Pair</strong> contract does not exist, a new one can be permissionlessly created from the <strong>UniswapV2Factory</strong> contract. <strong>UniswapV2Pair</strong> contracts are also ERC 20 tokens (they inherit from ERC 20), and that token is used to track deposits similar to how ERC 4626 works.<p>Although advanced traders or smart contracts can interact directly with a <strong>pair</strong> contract, most users will interact with a <strong>pair</strong> through a <strong>router</strong> contract, which has several convenience functions such as trading between <strong>pairs</strong> in one transaction to create a “synthetic” pair if it doesn’t exist.<p>There’s really only <strong>three</strong> smart contracts at play in the Uniswap V2 system.<p><strong>Factory:</strong> <a href=https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol>github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol</a><p><strong>Pair:</strong> (which inherits ERC20): <a href=https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol>github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol</a><p><strong>Router:</strong> <a href=https://github.com/Uniswap/v2-periphery/tree/master/contracts>github.com/Uniswap/v2-periphery/tree/master/contracts</a><p><strong>The core - periphery pattern</strong><p>Observe that the router contract above is in a repository called “<strong>v2 periphery</strong>” and the pair is in the “<strong>v2 core</strong>” repository. Uniswap V2 follows the “<strong>core / periphery</strong>” design pattern where the most essential logic is held in the core while the “optional” logic is held in the periphery.<p>The intent behind this is to have the core hold as little code as possible, which reduces the possibility of bugs in the core business logic.<p><strong><a href=https://github.com/Uniswap/uniswap-v2-core>Uniswap V2 Core</a></strong> are the essential Uniswap V2 smart contracts, consisting of:<ul><li><strong><a href=https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2ERC20.sol>UniswapV2ERC20.sol</a>,</strong> contract is responsible for handling the LP tokens. It is a basic ERC20 contract, so we will not go over this.<li><strong><a href=https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol>UniswapV2Pair.sol</a></strong>, which implements core swapping and liquidity provision functionality<li><strong><a href=https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol>UniswapV2Factory.sol</a></strong>, which deploys <strong><a href=https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol>UniswapV2Pair.sol</a></strong> contracts for any ERC20 token/ERC20 token pair</ul><p><strong><a href=https://github.com/Uniswap/uniswap-v2-periphery>Uniswap V2 Periphery</a></strong> is an initial set of helpers, including:<ul><li><strong><a href=https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol>A router contract</a></strong> that performs the safety checks needed for safely swapping, adding, and removing liquidity.<li><strong><a href=https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Migrator.sol>A migrator contract</a></strong> that can remove liquidity from Uniswap V1 and deposit it into Uniswap V2 in a single transaction.<li><strong><a href=https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol>A library contract</a></strong> that can be used in the creation of other helper contracts.<li><strong><a href=https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol>An example oracle contract</a></strong> that creates a simple TWAP from Uniswap V2 cumulative prices.<li><strong><a href=https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleFlashSwap.sol>An example flash swap contract</a></strong> that withdraws ERC20 tokens, executes arbitrary code, and then pays for them.</ul><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter3_3.webp><p><strong>How to locate a pool, given two token addresses</strong><p>Instead of accessing a mapping from token pairs to pool address, smart contracts calculate the address of the pool by predicting the <code>create2</code> address as a function of the token addresses and the factory address. Since there is no storage access, this is very gas efficient. Below is the helper function provided by <strong>UniswapV2Library</strong> for calculating the address of the <strong>Pair</strong> contract.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter3_4.webp><p><strong>Why not use clones</strong><p>The <a href=https://www.rareskills.io/post/eip-1167-minimal-proxy-standard-with-initialization-clone-pattern>EIP 1167 clone</a> pattern is used to create a collection of similar contracts, so why not use that here? Although the deployment would be cheaper, it would introduce an extra 2,600 gas per transaction due to the <strong>delegatecall</strong>. Since pools are intended to be used frequently, the cost savings from deployment would eventually be lost after a few hundred transactions, so it is worth deploying a pool as a new contract.<h1 id=chapter-4-uniswap-v2-swap-function><a aria-label="Anchor link for: chapter-4-uniswap-v2-swap-function" class=zola-anchor href=#chapter-4-uniswap-v2-swap-function><strong>Chapter - 4 :Uniswap V2 Swap Function</strong></a></h1><p><em><strong>Breaking Down the Uniswap V2 Swap Function.</strong></em><p><strong>UniswapV2Pair.sol#swap()</strong> : <a href=https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L159>https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L159</a></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_1.webp><ul><li><p>Line <strong>170-171</strong> directly transfers out the amount of tokens that the trader requested in the function arguments. <strong>There is no place inside the function where tokens are transferred in. But this does not mean we can just call swap and drain all the tokens we want to!</strong></p><li><p>The reason we can remove tokens right away is so that we can do <strong>flash loans</strong>. Of course, the require statement on line <strong>182</strong> (orange arrow) will require us to pay back the flash loan with interest.</p><li><p>At the top of the function, there is a comment which says the function should be called from another smart contract which implements important safety checks. That means <strong>this function in particular is missing safety checks.</strong></p><li><p>The <strong>variables <code>_reserve0</code> and <code>_reserve1</code></strong> are read on lines <strong>161</strong>, <strong>176</strong>-<strong>177</strong>, and <strong>182</strong>, but they <strong>are not written to in this function</strong>.</p> <ul><li><p><code>_reserve0</code>: Reserves of token <code>x</code> prior to the swap.</p><li><p><code>_reserve1</code>: Reserves of token <code>y</code> prior to the swap.</p></ul><li><p>Line <strong>182</strong> (orange arrow) does not strictly check if <code>X × Y = K</code>. It checks if <code>balance1Adjusted × balance2Adjusted ≥ K</code>. <strong>This is the only require statement that does something “interesting.”</strong> The other require statements check that values aren’t zero or that you aren’t sending the tokens to their own contract address.</p> <ul><li><p><code>balance0Adjusted</code>: Reserves of <strong>x</strong> after the trader sends tokensX to the pool minus 0.3% of the amount sent.</p><li><p><code>balance1Adjusted</code>: Reserves of <strong>y</strong> after the tokensY are sent to the trader from the pool minus 0.3%.</p></ul><li><p><code>balance0</code> and <code>balance1</code> are directly read from the actual balance of the pair contract using ER20 balanceOf.</p><li><p>Line <strong>172</strong> (below the yellow box) is only executed if data is non-empty, otherwise it is not executed</p></ul><p><strong>We can use Swap() function for :</strong><ul><li><p><strong>Flash Loan</strong></p><li><p><strong>Swapping one token for other</strong></p></ul><h3 id=flash-borrowing><a aria-label="Anchor link for: flash-borrowing" class=zola-anchor href=#flash-borrowing>Flash Borrowing</a></h3><p>Users do not have to use the swap function for trading tokens, it can be used purely as a flash loan.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_2.webp><p>The borrowing contract simply requests the amount of tokens they wish to borrow (<strong>A</strong>) without collateral and they will be transferred to the contract (<strong>B</strong>).<p>The <code>data</code> that should be provided with the function call is passed in as a function argument (<strong>C</strong>), and this will be passed to a function that implements.<p><strong>IUniswapV2Callee</strong>. The function <strong><code>uniswapV2Call</code></strong> must pay back the flash loan plus the fee or the transaction will revert.<h2 id=swap><a aria-label="Anchor link for: swap" class=zola-anchor href=#swap><strong>Swap</strong></a></h2><p>If a flash loan is not used, the <strong>incoming tokens must be sent as part of calling the swap function</strong>.<p>It should be clear that <strong>only a smart contract is able to interact with a swap function</strong>, because an EOA cannot simultaneously <strong>send the incoming ERC20 tokens and call swap in one transaction</strong> without the aid of another smart contract.<h2 id=measuring-the-amount-of-incoming-tokens><a aria-label="Anchor link for: measuring-the-amount-of-incoming-tokens" class=zola-anchor href=#measuring-the-amount-of-incoming-tokens><strong>Measuring the amount of incoming tokens</strong></a></h2><p>The way Uniswap V2 “measures” the amount of tokens sent in is done on line <strong>176</strong> and <strong>177.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_3.webp><ul><li><p><code>_reserve0</code> and <code>_reserve1</code> are not updated inside this function.</p><li><p>They reflect the <strong>balance of the contract before the new set of tokens were sent in</strong> as part of the swap.</p></ul><p>One of two things can happen for each of the two tokens in the pair:<ol><li><p>The pool had a net increase in the amount of a particular token.</p><li><p>The pool had a net decrease (or no change) in the amount of a particular token.</p></ol><p>The way the code determines which situation happened with the following lines:<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
</span><span>uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
</span></code></pre><p>The above two lines were doing the following thing</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_4.png><p>If it measures a net <strong>decrease</strong>, the ternary operator returns <strong>zero</strong>, otherwise it will measure the net <strong>gain</strong> of tokens in.<p>Simply,<ul><li>If the a token (0 or 1) ************************************is sent, the amount in to corresponding token will be <code>amountXIn = balanceX - (_reserveX - amountXOut)</code><li>If no token is sent <code>amountXIn</code> will become <strong><strong><strong><strong><strong>zero.</strong></strong></strong></strong></strong></ul><p>It is always the case that <code>_reserveX > amountXOut</code> because of the require statement on line <strong>162</strong>.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_5.png><h2 id=balancing-xy-k><a aria-label="Anchor link for: balancing-xy-k" class=zola-anchor href=#balancing-xy-k>Balancing XY = K</a></h2><p>Now that we know how many tokens the user sent in, let’s see how to enforce XY = K.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_6.webp><p>Uniswap V2 charges a hardcoded <strong>0.3% per swap</strong>, which is why we see the numbers 1000 and 3 at play.<p><code>reserve0</code> - Balance of token0 before swap<p><code>balance0</code> - Balance of token0 after swap<p><code>reserve1</code> - Balance of token1 before swap<p><code>balance1</code> - Balance of token1 after swap<p><code>balance0Adjusted</code> - Updated balance of token0(<strong>X</strong>) minus 0.3% fee.<p><code>balance1Adjusted</code> - Updated balance of token1(<strong>Y)</strong> minus 0.3% fee.<p>The line <strong>182</strong> is checking the following condition.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_7.webp><p>Particularly, doing this with fee.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_8.webp><p><strong>K is not really a constant</strong><ul><li><p>Think about it this way, if someone donated tokens to the pool and changed the value of K</p><li><p>Uniswap V2 doesn’t prevent you from <strong>“paying too much</strong>” i.e. transferring in too many tokens in during the swap (this is related to one of the <strong>safety checks</strong>)</p><li><p><code>require</code> statement is reverts if the loss the of the pool(<strong>K</strong>)</p></ul><p><strong>Accounting fot Fee</strong><ul><li><p>But not only do we want K to get larger, we want it to <strong>get larger by at least an amount that enforces the 0.3% fee</strong>.</p><li><p><strong>Fee only applies to the tokens that go in, not on the tokens that go out.</strong></p> <ul><li><p>Suppose we put in 1000 of token0 and remove 1000 of token1. We would need to pay a fee of 3 on token0 and no fee on token1.</p><li><p>Suppose we borrow 1000 of token0 and do not borrow token1. We are going to have to put 1000 of token0 back in, and we will have to pay a 0.3% fee on that — 3 of token0.</p></ul><li><p>Observe that if we <strong>flash borrow</strong> one of the tokens, it results in the <strong>same fee as swapping</strong> that token for the same amount. You pay <strong>fees on tokens in, not on tokens out</strong>.</p><li><p>But if you don’t put tokens in, there is no way for you to borrow or swap.</p></ul><h2 id=updating-reserves><a aria-label="Anchor link for: updating-reserves" class=zola-anchor href=#updating-reserves>Updating Reserves</a></h2><p>Now that the trade is completed, then the “<strong>previous balance</strong>” must be replaced with the current balance. This happens in the call to the <code>_update()</code> function at the end of <code>swap()</code>.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter4_9.webp><p>There is a lot of logic here to handle the <strong>TWAP oracle</strong>, but all we care about for now is lines <strong>82</strong> an <strong>83</strong> where the storage variables <code>reserve0</code> and <code>reserve1</code> are updated to reflect the changed balances. The arguments <code>_reserve0</code> and <code>_reserve1</code> are used to update the oracle, but they are not stored.<h2 id=safety-checks-in-swap><a aria-label="Anchor link for: safety-checks-in-swap" class=zola-anchor href=#safety-checks-in-swap>Safety Checks in Swap</a></h2><p>There are two things that can go wrong:<ol><li><p>The <strong>amountIn</strong> is not enforce to be optimal, so the user might <strong>overpay</strong> for the swap</p><li><p>AmountOut has no flexibility as it is supplied as a parameter argument. If the amountIn turns out to not be sufficient relative to amountOut, the transaction will revert and gas will be wasted.</p></ol><p>These circumstances can happen if someone <strong>frontruns</strong> a transaction (intentionally or not) and changes the ratio of assets in the pool in an undesirable direction.<p><strong>Example on swap</strong><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>- Swap Function: swap()
</span><span>***********************
</span><span>- The swap() function is used by traders to swap tokens
</span><span>- The swap function ensures that the amount of token you are swapping to is greater than zero (It can be any of the tokens in the pair contract) : Only one of the tokens can have value greater than zero at a time.
</span><span>- It also ensures that the amount of token you are swapping from and the amount of token you are swapping to is less than the available reserve: hence it will throw an INSUFFICIENT LIQUIDITY error.
</span><span>
</span><span>- If this checks are passed, it checks which of the amount out (amount0Out or amount1Out) that is greater than zero, then it transfers the amount out to the trader optimistically.
</span><span>
</span><span>- Note: without making sure that the trader has already transferred corresponding tokens into our balance. We can optimistically transfer tokens out because the swap function have assertions later in the function to check if we received corresponding tokens (the Periphery contract should send in the tokens to the pair contract before calling it for the swap). If the pair contract have not received any tokens, assertions will fail and Solidity will revert the entire function.
</span><span>
</span><span>- The code: if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
</span><span>will inform the receiver about the swap if requested
</span><span>
</span><span>- Then it will check how many tokens was received by the pair contract.
</span><span>
</span><span>- amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0
</span><span>- amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0
</span><span>
</span><span>Let's assume:
</span><span>- reserve0 = 1000
</span><span>- reserve1 = 500
</span><span>
</span><span>A user is swapping 100 token0
</span><span>This means the user will get 50 token1
</span><span>
</span><span>token0 incoming = 100
</span><span>token1 incoming = 0
</span><span>
</span><span>token0 outgoing = 0
</span><span>token1 outgoing = 50
</span><span>
</span><span>At this point: 
</span><span>balance0 = 1100
</span><span>balance1 = 450
</span><span>
</span><span>Using this formula:
</span><span>- amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0
</span><span>- amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0
</span><span>
</span><span>amount0In = 1100 > 1000 - 0 ? 1100 - (1000 - 0) : 0
</span><span>
</span><span>amount0In = 100
</span><span>
</span><span>amount1In = 450 > 500 - 50 ? 450 - (500 - 50) : 0
</span><span>amount1In = 0
</span><span>
</span><span>- If the amountIn of either tokens of the pair contract is less than zero, it will revert with: INSUFFICIENT_INPUT_AMOUNT and the entire function will revert and nothing will have taken place.
</span><span>
</span><span>- If the checks passes, then it proceeds to where the 0.3% fee paid by traders is calculated. It does this calculation to check and ensure that the fee was paid. Note the fee is also transferred to the pair contract and this is made possible by the Router contract.
</span><span>
</span><span>- This is calculated by:
</span><span>- balance0Adjusted = (balance0 * 1000) - (amount0In * 3)
</span><span>- balance1Adjusted = (balance1 * 1000) - (amount1In * 3)
</span><span>
</span><span>Remember:
</span><span>balance0 = 1100
</span><span>balance1 = 450
</span><span>
</span><span>- balance0Adjusted = (1100 * 1000) - (100 * 3)
</span><span>- balance0Adjusted = 1100000 - 300
</span><span>- balance0Adjusted = 1099700
</span><span>
</span><span>- balance1Adjusted = (450 * 1000) - (0 * 3)
</span><span>- balance1Adjusted = 450000 - 0
</span><span>- balance1Adjusted = 450000
</span><span>
</span><span>- Then it checks if the k value (x*y=k) has decreased after the trade. The k value can never decrease because otherwise, Uniswap would lose from the swap.
</span><span>**
</span><span>require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
</span><span>**
</span><span>
</span><span>Remember k = x*y
</span><span>
</span><span>adjustedK = balance0Adjusted * balance1Adjusted
</span><span>previousK = (_reserve0 * _reserve1) * 1000^2 
</span><span>
</span><span>adjustedK = 1099700 * 450000
</span><span>adjustedK = 494865000000
</span><span>
</span><span>previousK = (1000 * 500) * 1000^2
</span><span>previousK = 500000000000
</span><span>
</span><span>(The 1000^2 is because we multiplied balance0 and balance1 by 1000 when calculating the balance0Adjusted and balance1Adjusted)
</span><span>
</span><span>- Finally, the _update() function is called to update the known reserves with the new balances and emit a Swap event.
</span></code></pre><h1 id=chapter-5-mint-and-burn-functions><a aria-label="Anchor link for: chapter-5-mint-and-burn-functions" class=zola-anchor href=#chapter-5-mint-and-burn-functions><strong>Chapter - 5 : Mint and Burn Functions</strong></a></h1><ul><li><input disabled type=checkbox> Useful : <a href=https://flow.com/engineering-blogs/uniswap-v2-explained-beginner-friendly><strong>https://flow.com/engineering-blogs/uniswap-v2-explained-beginner-friendly</strong></a></ul><p>The lifecycle of Uniswap V2 is someone mints LP tokens (supplies liquidity, i.e. tokens to the pool) for the first time, then a second depositor mints liquidity, swaps happen, then eventually the liquidity providers burn their LP tokens to redeem the pool tokens.<h2 id=uniswap-v2-burn><a aria-label="Anchor link for: uniswap-v2-burn" class=zola-anchor href=#uniswap-v2-burn><strong>Uniswap V2 Burn</strong></a></h2><p>Before liquidity tokens can be burned, there needs to be liquidity in the pool, so let’s make that assumption. We assume that there are two tokens in the system: token0 and token1.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter5_1.webp><ul><li><p>On line <strong>140</strong> (purple box), <strong>liquidity</strong> is measured by the amount of LP tokens owned by the pool contract.</p><li><p>It is assumed that the burner sent in LP tokens before calling burn, but advisably as part of <strong>one transaction.</strong> (<strong>If they are sent as two transactions, someone else can burn your LP tokens and remove your liquidity!</strong>)</p><li><p>The amount the user sent to the contract will be burned. In general, we can assume that the contract will have zero balance of LP tokens, because if LP tokens are just sitting in the pair contract, someone will burn them and claim some of the token0 and token1 for free.</p></ul><p>The red boxes on lines <strong>142</strong> and <strong>154</strong> denote <strong>fees</strong>, we will skip those for now as Uniswap does not apply fees to liquidity providers.<p>The orange boxes on lines <strong>144</strong> to <strong>145</strong> are where the amounts that the LP provider will get back are calculated. If the total supply of liquidity tokens is 1,000, and they burn 100 LP tokens, then they get 10% of the token0 and token1 held by the pool. Liquidity / totalSupply is their burned share of the total supply of LP tokens.<p>The blue box on line <strong>147</strong> to <strong>149</strong> is where the <strong>LP tokens</strong> are actually <strong>burned</strong> and the token0 and token1 are sent to the liquidity provider.<p>The (yellow box) on lines <strong>150</strong>-<strong>151</strong> updates balance variables so that the call to <code>_update</code> on line <strong>153</strong> (green box) can update the <code>_reserve</code> variables. Aside from updating the <strong>TWAP</strong>, the <code>_update</code> function simply updates the <code>_reserve</code> variables.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter5_2.webp><p><strong>lock modifier</strong><p>The <code>lock</code> modifier prevents reentrancy attack by setting the initial value of <code>unlocked</code> state variable to 1. Once a function with <code>lock</code> modifier is executed, the <code>unlocked</code> state variable value will be set to 0. To reenter the contract, the <code>unlocked</code> state variable is required to be == 1, thus preventing reentrancy. The <code>unlocked</code> state variable value will return to 1 upon successful execution of the function or failed execution (reversion to original state). Uniswap applies the <code>lock</code> modifier to all the <em>UniswapV2Pair</em> functions that perform external calls, such as <code>mint</code>, <code>burn</code>, <code>swap</code> and <code>skim</code>. Essentially this function modifier <strong>prevents 2 different parts</strong> of this contract to be executed simultaneously.<h2 id=safety-checks-in-burn><a aria-label="Anchor link for: safety-checks-in-burn" class=zola-anchor href=#safety-checks-in-burn>Safety checks in burn</a></h2><p>The amount of token0 and token1 that the liquidity provider gets depends on the ratio of the LP tokens they burn to the total supply of LP tokens. However, the totalSupply can change before the burn transaction is confirmed. This means that the contract interacting with burn needs to implement <strong>slippage checks.</strong><p><strong>Example burn</strong><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>- Burn Function: burn()
</span><span>***********************
</span><span>
</span><span>- The burn() function is the exact opposite of the mint() function
</span><span>- The same gas saving mechanism is used just like in the mint() function
</span><span>- balance0 and balance1 are total balances of the pair tokens in this pool
</span><span>
</span><span>- balance0 = IERC20(_token0).balanceOf(address(this))
</span><span>- balance1 = IERC20(_token1).balanceOf(address(this))
</span><span>- liquidity = balanceOf[address(this)];
</span><span>
</span><span>- liquidity is the amount of pool ownership tokens that the liquidity provider (who wishes to cash out) has. 
</span><span>
</span><span>--- QUESTION ---
</span><span>- But Why do we access the liquidity as the balance of address(this)? 
</span><span>
</span><span>--- ANSWER ---
</span><span>- Because the liquidity was transferred to the Pair contract by the Periphery (Router) contract before calling the burn function.
</span><span>
</span><span>- The amount of token to withdraw to the liquidity provider is proportional to the amount of Pool Ownership tokens (LP tokens) he has and this is calculated by:
</span><span>- amount0 = (liquidity * balance0) / totalSupply
</span><span>- amount1 = (liquidity * balance1) / totalSupply
</span><span>
</span><span>- After the amount is calculated, the burn function is called, which burns the LP token of the liquidity provider that was transferred into the contract from the contract.
</span><span>- Then it transfers the pair token the the liquidity provider used in providing liquidity. (This transfer also includes the accumulated rewards from traders fees over time)
</span><span>- The _update() function is called again which updated the reserves(reserve0 and reserve1) with the new balance (balance0 and balance1) after the pair tokens (token0 and token1) + the rewards have been transferred to the liquidity provider that removed their liquidity.
</span><span>
</span><span>reserve0 = 1000
</span><span>reserve1 = 500
</span><span>
</span><span>balance0 = 1000
</span><span>balance1 = 500
</span><span>
</span><span>liquidity = 706
</span><span>totalSupply = 1706
</span><span>
</span><span>amount0 = liquidity.mul(balance0) / _totalSupply;
</span><span>
</span><span>amount0 = (706 * 1000) / 1706
</span><span>amount0 = 706000 / 1706
</span><span>amount0 = 413.8335
</span><span>amount0 = 413
</span><span>
</span><span>amount1 = liquidity.mul(balance1) / _totalSupply;
</span><span>amount1 = (706 * 500) / 1706
</span><span>amount1 = 353000 / 1706
</span><span>amount1 = 206.91676
</span><span>amount1 = 206
</span><span>
</span><span>balance0 = 1000 - 413
</span><span>balance0 = 587
</span><span>
</span><span>balance1 = 500 - 206
</span><span>balance1 = 294
</span><span>
</span><span>reserve0 = 587
</span><span>reserve1 = 294
</span><span>
</span><span>kLast = 172578
</span></code></pre><h2 id=uniswap-v2-mint><a aria-label="Anchor link for: uniswap-v2-mint" class=zola-anchor href=#uniswap-v2-mint>Uniswap V2 Mint</a></h2><p>Here is the mint liquidity function. Much of the functionality is similar to burn.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter5_3.webp><p><strong>Uniswap V2 mint function deals two different cases when minting liquidity.</strong><ol><li><p>Minting liquidity when the pool is not empty</p><li><p>Minting initial liquidity. i.e, pool is empty</p></ol><h2 id=minting-liquidity-when-the-pool-is-not-empty><a aria-label="Anchor link for: minting-liquidity-when-the-pool-is-not-empty" class=zola-anchor href=#minting-liquidity-when-the-pool-is-not-empty><strong>Minting liquidity when the pool is not empty</strong></a></h2><p>The liquidity that is credited to the user, and later minted to them on line <strong>126</strong> (green box), is the lesser of two values.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter5_4.webp><p>The ratio that line of code is measuring is amount0 / _reserve0 — scaled by the totalSupply of LP tokens.<p>Let’s say there are 10 token0 and 10 token1. If the user supplied 10 token0 and 0 token1 they will get the minimum of (10/10, 0/10) and get zero liquidity tokens back!<p>Another <strong>example</strong>: if they increase the supply of token0 by 5% and token1 by 10%, they will only get minted 5% of the supply of LP tokens (remember, this ratio is scaled by _totalSupply which is the current supply of LP tokens).<p><strong>The fact that the user will get the worse of the two ratios (amount0 / _reserve0 or amount1 / _reserve1) they provide incentivizes them to increase the supply of token0 and token1 without changing the ratio of token0 and token1.</strong><p>If the ratio is not the same as what the pool currently has, then there are always some tokens <strong>wasted</strong> in the sense that those tokens were added to the pool but no additional liquidity tokens were minted to the liquidity provider.<p>With this rule, the liquidity providers are incentivized to add tokens at the same ratio as the pool. And we know the rate is always close to the market price otherwise Arbitrageurs will arbitrage if the token ratio was off the market.<p>Why enforce this? Let’s say the pool currently has 100 of token0 and 1 of token1, and the supply of LP tokens is 1. Let’s say the total value, in dollars, of both tokens is $100 each, so the total value of the pool is $200.<p>If we took the <em><strong>maximum</strong></em> of the two ratios, someone could supply one additional token1 (at a cost of $100) and raise the pool value to $300. They’ve increase the pool value by 50%. However, under the maximum calculation, they would get minted 1 LP tokens, meaning they own 50% of the supply of the LP tokens, since the total circulating supply is now 2 LP tokens. Now they control 50% of the $300 pool (worth $150) by only depositing $100 of value. This is clearly stealing from other LP providers.<p><strong>Supply Ratio Safety Check</strong><p>The user might try to respect the token ratios, but if another transaction executes in front of them and changes the balance of token 0 to token 1, then they will get fewer liquidity tokens back than they expected.<p>Uniswap doesn't require exact amounts because otherwise the transaction would likely revert. Another transaction executed first would change the requirement between when the minter sent the transaction and when it was included in the block.<p><strong>TotalSupply safety check</strong><p>Just like the burn case, the totalSupply of LP tokens could change at the time, so some slippage protection must be implemented.<h2 id=minting-liquidity-when-the-pool-is-empty-first-minting><a aria-label="Anchor link for: minting-liquidity-when-the-pool-is-empty-first-minting" class=zola-anchor href=#minting-liquidity-when-the-pool-is-empty-first-minting><strong>Minting liquidity when the pool is empty (First Minting)</strong></a></h2><p>Uniswap uses a special case when minting for the first time in pool to mitigate the <strong><a href=https://tienshaoku.medium.com/eip-4626-inflation-sandwich-attack-deep-dive-and-how-to-solve-it-9e3e320cc3f1>inflation attack</a></strong> by using the <strong>MINIMUM_LIQUIDITY.</strong><p>This is locked by sending the Mininum Liquidity to address(0) : Once this is done, the <strong>total supply can never be reduced</strong> to zero again even if the liquidity providers remove their liquidity from the pool. A brand new pool needs to lock in MINIMUM_LIQUIDITY amount of pool ownership (LP) token to avoid division by zero in the liquidity calculations.<p><code>MINIMUM_LIQUIDITY</code> is 10**3. It may be possible to prevent indiscriminate proliferation of pairs, but in fact, it burns. Since 1000 burns, it means that <code>MINIMUM_LIQUIDITY</code> must be exceeded.<p><strong><a href="https://www.notion.so/Example-of-inflation-attack-32937d642ed74b3baa8711177984425a?pvs=21"><strong>Example of inflation attack</strong></a></strong><h3 id=why-uniswap-calculates-liquidity-as-square-root-k><a aria-label="Anchor link for: why-uniswap-calculates-liquidity-as-square-root-k" class=zola-anchor href=#why-uniswap-calculates-liquidity-as-square-root-k>Why Uniswap Calculates Liquidity as Square Root K</a></h3><p>The more interesting question is why Uniswap V2 takes the square root of the product of the tokens supplied to calculate the amount of LP shares to mint.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter5_5.webp><p><strong>It would seem that we could mint an arbitrary amount of tokens to the first LP — they own 100% of the shares (minus what was burned), so what difference does it make if it is scaled by 0.01 or 100?</strong><p><strong>Example: Doubling Liquidity</strong><p>Let’s suppose we didn’t measure liquidity with the square root function and we start with 10 of token0 and 10 of token1 in the pool. Later on, the pool has 20 of token0 and 20 of token1 in the pool.<p>Intuitively, did the liquidity double or quadruple? Because if we don’t take the square root, liquidity would start at 100 (10 × 10) and end up at 400 (20 × 20). Arguably, liquidity did not quadruple. At first, the maximum of token0 you could obtain was (asymptotically) 100, but after the growth in liquidity, the “depth” of the liquidity for that token doubled, not quadrupled.<p>But how does this matter if future liquidity providers are not calculating liquidity using the square root while minting or burning? We saw new liquidity providers are “forced” to supply assets at the current rate, and burners can only redeem at the current rate — no square roots are involved.<p>The answer lies in how Uniswap would have collected fees from LPs if it chose to do so.<p><strong>Example mint:</strong><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>- Mint Function: mint()
</span><span>***********************
</span><span>
</span><span>- If the pool is a brand new pool,
</span><span>- Liquidity is calculated using:
</span><span>- liquidity = Math.sqrt( (amount0 * amount1) - MINIMUM_LIQUIDITY )
</span><span>
</span><span>reserve0 = 0
</span><span>reserve1 = 0
</span><span>balance0 = 1000 // amount of token0 sent (Shiba)
</span><span>balance1 = 500 // amount of token1 sent (Doge)
</span><span>
</span><span>amount0 = 1000 - 0
</span><span>amount1 = 500 - 0
</span><span>
</span><span>amount0 = 1000
</span><span>amount1 = 500
</span><span>
</span><span>_totalSupply = 0
</span><span>MINIMUM_LIQUIDITY 10 ^ 3
</span><span>
</span><span>liquidity = Math.sqrt( (1000 * 500) - 1000)
</span><span>liquidity = Math.sqrt(499000)
</span><span>liquidity = 706.399320498
</span><span>liquidity = 706
</span><span>
</span><span>totalSupply = 706 + 1000
</span><span>totalSupply = 1706
</span><span>
</span><span>After this, reserves are updated and kLast is updated too
</span><span>reserve0 = 1000
</span><span>reserve1 = 500
</span><span>kLast = 500000
</span><span>
</span><span>- If the pool is not brand new
</span><span>- Liquidity is calculated using:
</span><span>- liquidity = Math.min( (amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1 )
</span></code></pre><h2 id=fees><a aria-label="Anchor link for: fees" class=zola-anchor href=#fees>Fees</a></h2><p>Going back to our earlier example of the pool growing from 100 of token0 and 100 of token1, to 200 of each, the profit of the liquidity provider is 100%, so they should pay a fee proportional to that amount. If we measured the size of the pool from 100 to 400, then they would have to pay fees on quadruple profit.<p><strong>Uniswap opts to charge fees during liquidity removal because</strong> charging a protocol fee during swapping would increase the gas cost of a very common operation.<p>Uniswap V2 never actually turned on the protocol fee, so this discussion is a bit theoretical.<h1 id=chapter-6-protocol-mint-fee><a aria-label="Anchor link for: chapter-6-protocol-mint-fee" class=zola-anchor href=#chapter-6-protocol-mint-fee><strong>Chapter - 6 : Protocol Mint Fee</strong></a></h1><p>Uniswap V2 was designed to collect <strong>1/6th of the swap fees</strong> to the protocol. Since a swap fee is 0.3%, 1/6th of that is 0.05%, so 0.05% of every trade would go to the protocol.<p>Although this feature was never actually activated, this feature anyway since some forks may use it. <strong>The fee is paid to <code>feeTo</code> address in LP Tokens.</strong><p><strong>Collecting protocol fees during swaps is inefficient</strong><p>It would be inefficient to collect 0.05% of the fee on every trade because that would require additional token transfers.Therefore, the <strong>fee is collected when</strong> a liquidity provider calls <strong>burn</strong> or <strong>mint</strong>. Since these operations are infrequent compared to swapping tokens, this will lead to gas savings. To collect the <code>mintFee</code>, the contract calculates the amount of fees collected since that last happened, and mints enough LP tokens to the beneficiary address such that the beneficiary is entitled to 1/6th of the fee.<p><strong>fee</strong> - the 0.3% collected from traders during the swap<p><strong>mintFee</strong> - the 1/6th of the 0.3% fee.<p><strong>Liquidity(L)</strong> is the <strong>square root</strong> of the products of the token balances in the pool. <code>sqrt(K)</code>.<h2 id=computing-the-mintfee-assumptions><a aria-label="Anchor link for: computing-the-mintfee-assumptions" class=zola-anchor href=#computing-the-mintfee-assumptions>Computing the mintFee assumptions</a></h2><p>For this to work, Uniswap V2 relies on the following two invariants:<ul><li>If <strong>mint</strong> and <strong>burn</strong> are not called, the liquidity of the pool can only increase.<li>The increase in liquidity is purely due to fees (or donations).</ul><p>By measuring the increase in liquidity since the last <strong>mint</strong> or <strong>burn</strong>, the pool knows how much fees were collected.<h2 id=calculation-of-mintfee><a aria-label="Anchor link for: calculation-of-mintfee" class=zola-anchor href=#calculation-of-mintfee><strong>Calculation of mintFee</strong></a></h2><p>Suppose at t₁ the pool starts at 10 <strong>token0</strong> and 10 <strong>token1</strong>.<p>After a lot of trading and fee collection, the new pool balance is 40 token0 and 40 token1 at t₂.<p>Liquidity is measured as the square root of the product of the two tokens, i.e. liquidity = sqrt(xy). The liquidity was 10 at t₁ and 40 at t₂, sqrt(100) and sqrt(1600) respectively. We are going to charge a fee on the growth from 10 to 40.<p><strong>Specifically, 3/4ths, or 30 units of liquidity of the pool is due to fees. We want to mint enough LP tokens, the “mintFee” such that the beneficiary receives 1/6th of the “fee portion” of the pool. That is, they should be entitled to 5 units of liquidity (30 / 6).</strong><p>Remember, the mint fee is dilutive. We mint more such that the proportional ownership of the liquidity providers is reduced.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_1.webp><p>The key insight is the invariant</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_2.webp><p><strong>That is, if the mintFee η can redeem the amount of liquidity due to the protocol 𝑝, then the original LP supply 𝑠 can redeem the rest of the pool 𝑑.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_3.webp><ul><li><p>current liquidity after fees ℓ₂ is <strong>rootK</strong></p><li><p>previous liquidity is <strong>kLast</strong></p><li><p>the supply of LP tokens before dilution s is <strong>totalSupply</strong></p><li><p>the function is state changing, it mints the mintFee inside the function rather than return the calculation of the mintFee (blue highlight)</p><li><p>the fee can be switched on an off with the flag <strong>feeOn</strong> which we haven’t discussed yet</p></ul><p><strong>Or simply,</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_4.webp><p><code>_mintFee</code> is doing what exactly the same the above formulae.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_5.webp><h3 id=where-klast-gets-updated><a aria-label="Anchor link for: where-klast-gets-updated" class=zola-anchor href=#where-klast-gets-updated><strong>Where klast gets updated</strong></a></h3><p>In the code above, kLast is not set unless <strong>feeOn</strong> is switched to false. It is set at the completion of mint and burn but not swap because we are interested in measuring the growth of fees due to swaps between liquidity deposit and withdrawal events.<p><strong><code>mint</code> function</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_6.webp><p><strong><code>burn</code> function</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_7.webp><h2 id=explaination><a aria-label="Anchor link for: explaination" class=zola-anchor href=#explaination>Explaination</a></h2><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_8.webp><p>Let’s consider the possibilities in the code snippet above, repeated for convenience.<ol><li><p>The <strong>feeOn</strong> is <strong>false</strong>, nothing is minted (green highlight)</p><li><p>The <strong>feeOn</strong> is <strong>false</strong>, kLast is zero (yellow highlight)</p><li><p>The <strong>feeOn</strong> is <strong>false</strong>, kLast is not zero (yellow highlight)</p><li><p>The <strong>feeOn</strong> is <strong>true</strong>, but there was no growth in liquidity (orange highlight)</p><li><p>The <strong>feeOn</strong> is <strong>true</strong>, and there was liquidity growth (orange highlight), so the mint fee applies (blue highlight)</p></ol><p>It’s easier to see the logic in a decision tree, so here is the decision tree with the branches colored the same as the if statements.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter6_9.webp><p><strong>Example</strong><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>Asumming:
</span><span>reserve0 = 1000
</span><span>reserve1 = 500
</span><span>klast = 1000 * 500
</span><span>klast = 500000
</span><span>
</span><span>new liquidity:
</span><span>token0 100
</span><span>token1 50
</span><span>
</span><span>currentReserve0 = 1000 + 100 = 1100
</span><span>currentReserve1 = 500 + 50 = 550
</span><span>
</span><span>rootK = Math.sqrt(currentReserve0 * currentReserve1)
</span><span>rootK = Math.sqrt(605000)
</span><span>rootK = 777.8174593052 (round down)
</span><span>rootK = 777
</span><span>
</span><span>rootKLast = Math.sqrt(_kLast);
</span><span>rootKLast = Math.sqrt(500000);
</span><span>rootKLast = 707.1067811865
</span><span>rootKLast = 707
</span><span>
</span><span>kDifference = rootK - rootKLast
</span><span>kDifference = 777.8174593052 - 707.1067811865
</span><span>kDifference = 70.7106781187
</span><span>kDifference = 70
</span><span>
</span><span>using totalSupply = 499000 (s1)
</span><span>
</span><span>numerator = totalSupply * kDifference
</span><span>numerator = 499000 * 70
</span><span>numerator = 34930000
</span><span>
</span><span>denominator = (rootK * 5) + rootKLast
</span><span>denominator = (777 * 5) + 707
</span><span>denominator = 3885 + 707
</span><span>denominator = 4592
</span><span>
</span><span>liquidity = numerator / denominator
</span><span>liquidity = 34930000 / 4592
</span><span>liquidity = 7606.7073170732 (round down)
</span><span>liquidity = 7606 (This liquidity goes to Uniswap: feeTo address)
</span><span>
</span><span>7606 amount of LP Tokens to feeTo address
</span></code></pre><h1 id=chapter-7-twap-oracle><a aria-label="Anchor link for: chapter-7-twap-oracle" class=zola-anchor href=#chapter-7-twap-oracle><strong>Chapter - 7 : TWAP Oracle</strong></a></h1><p><strong>Time Weighted Average Price</strong><p><strong>What exactly <code>Price</code> in Uniswap ?</strong><p>Suppose we have 1 Ether and 2,000 USDC in a pool. This implies that the price of Ether is 2,000 USDC. Specifically, the price of Ether is 2,000 USDC / 1 Ether (ignoring decimals).</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_1.webp><p>In the example above, it is saying “how may <strong>bars</strong> do you need to pay to get one <strong>foo</strong>” (ignoring fees).<h2 id=price-is-a-ratio><a aria-label="Anchor link for: price-is-a-ratio" class=zola-anchor href=#price-is-a-ratio>Price is a ratio</a></h2><p>Because price is a ratio, they need to be stored with a data type which has decimal points (which Solidity types do not have by default).<p>That is, we say Ethereum is 2000 and USDC (in price of Ethereum) is 0.0005 (this is ignoring decimals of both assets).<p>Uniswap uses a fixed point number with 112 bits of precision on each side of the decimal, this takes up a total of 224 bits, and when packed with a 32 bit number, it uses up a single slot.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_2.png><p><code>**UQ112x112</code>is a library for supporting floating numbers** since solidity does not support floating numbers default(floats are larger than integer so it will cost more gas fee). The last 112 bits is for fractional part.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_3.png><p>This library sets Q112 to <code>2¹¹²</code>. There are two functions, <code>encode</code> and <code>uqdiv</code>(decode).<p><code>encode</code> takes argument y and times it with Q112 while <code>uqdiv</code> divides a UQ112x112 by a uint112 and returns a UQ112x112.<p><strong>But why 112?</strong><ul><li><p>Since there is an unsigned type using <code>uint224</code>, 112 bits represent the previous significant digit, and the remaining 112 is the exponent. 112 + 112 = 224, and usually unsigned is 256, so 32 bits if subtracted from each other!</p><li><p>Expresses 32 bits as time.</p><li><p>The remaining 32 bits are used as time, which is used in UTC notation. Since people have been around for a long time, cast to <code>uint32(time)</code> form for UTC-based time and truncate it. Only look at the last one and use the interval difference using under/over flow in between.</p><li><p>2^32 - 1 second is very long. So, if 2^10 is 1000 and (10^3)^3, it takes almost 110 years.</p><li><p>Since there is unsigned 32bit, since the Robust Price Oracle Price is a rational expression, UQ112.112 is used.</p></ul><h2 id=oracle-definition><a aria-label="Anchor link for: oracle-definition" class=zola-anchor href=#oracle-definition><strong>Oracle definition</strong></a></h2><p>An oracle in computer science terms is a “source of truth.” A price oracle is a source of prices. <strong>Uniswap has an implied price when holding two assets, and other smart contracts can use this as a price oracle.</strong><p>The intended users of the oracle are other smart contracts, since other smart contracts can easily communicate with Uniswap to determine the price, but getting price data from an off-chain exchange would be a lot harder.<p>However, just taking the ratio of the balances to get the current price isn’t safe.<h2 id=motivation-behind-twap><a aria-label="Anchor link for: motivation-behind-twap" class=zola-anchor href=#motivation-behind-twap><strong>Motivation behind TWAP</strong></a></h2><ul><li><p>Measuring price at a single point of time may be prone to <strong>flash loan attack.</strong> That is an attacker could a huge amount of flash loan which leads to drastic change in price of the asset in the pool.</p><li><p>This may lead uninted behaviour in the contract that uses this price.</p></ul><p>The Uniswap V2 oracle defends against this in two ways:<ol><li><p>It provides a mechanisms for consumers of the price (usually smart contracts) to take the <strong>average a previous time period</strong> (decided by the user). This means an attacker has to constantly manipulate the price for several blocks, which is a lot more costly than using a flash loan.</p><li><p>It doesn’t incorporate the current balance into the oracle calculation</p></ol><p><strong>This should prone to price manipulation attacks</strong>.<ul><li>If the asset <strong>does not have much liquidity</strong>, or the <strong>time window</strong> of taking the average is <strong>not</strong> sufficiently <strong>large</strong>, then a well-resourced attacker can still prop up the price (or suppress the price) long enough to manipulate the average price at the time of measurement.</ul><h2 id=how-twap-works><a aria-label="Anchor link for: how-twap-works" class=zola-anchor href=#how-twap-works><strong>How TWAP works</strong></a></h2><p>A TWAP (Time Weighted Average Price) is the average of the price for the specified time interval.<p><strong>Example:</strong><p>Over the last day, the price of an asset was $10 for the first 23 hours and $11 for the most recent one. The expected average price should be closer to $10 than $11, but it will still be in between those values. Specifically, it will be ($10 * 23 + $11 * 1) / 24 = $10.0417</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_4.png><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_5.png><h2 id=uniswap-v2-does-not-store-lookback-or-the-denominator><a aria-label="Anchor link for: uniswap-v2-does-not-store-lookback-or-the-denominator" class=zola-anchor href=#uniswap-v2-does-not-store-lookback-or-the-denominator><strong>Uniswap V2 does not store lookback or the denominator</strong></a></h2><p>In our example above, we only looked at prices for the last 24 hours, but what if you care about prices for the last hour, week, or some other interval? <strong>Uniswap of course cannot store every look back</strong> that someone might be interested, and there also isn’t a good way to consistently snapshot the price as someone would have to pay for the gas.<p>The solution is that Uniswap only stores the <strong>numerator</strong> of values — <strong>every time a change is the liquidity ratio happens</strong> (mint, burn, swap, or sync are called), it records the new price and <strong>how long the previous price lasted.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_6.webp><p>The variables <code>price0Cumulativelast</code> and <code>price1CumulativeLast</code> are public, so an interested party needs to <strong>snapshot</strong> them.<ul><li><strong><code>price0CumulativeLast</code> and <code>price1CumulativeLast</code> are only updated on line 79, 80 there is no way to decrease them.</strong><li><strong>They always increase with every call to <code>_update</code> until they overflow.</strong></ul><h2 id=limiting-the-lookback-window><a aria-label="Anchor link for: limiting-the-lookback-window" class=zola-anchor href=#limiting-the-lookback-window><strong>Limiting the lookback window</strong></a></h2><p>We dont want the average price since the pool deployed. We want price in a certain amount of time.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_7.webp><p>If we are only interested in prices since T4, then we want to be doing the following</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_8.webp><p><strong>We can get this part of the TWAP since the <code>priceXCumulative</code> keeps tracks from the pool deployement.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_9.webp><p><strong>We need to isolate the part we want.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_10.webp><p><strong>If we can able to snapshot the price at the end of T3, we get the value <code>UpToTime3</code> .</strong><p><strong>Now we can get the cumulative price of the recent window by calculating</strong><p><strong><code>price0Cumulativelast - UpToTime3then</code></strong><p><strong>If we divide this value by the time of the recent window. We will get the price average for the recent window of time.</strong><p><strong>This is what we are doing.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_11.webp><h2 id=only-calculating-the-last-1-hour-twap-in-solidity><a aria-label="Anchor link for: only-calculating-the-last-1-hour-twap-in-solidity" class=zola-anchor href=#only-calculating-the-last-1-hour-twap-in-solidity><strong>Only calculating the last 1 hour TWAP in Solidity</strong></a></h2><p>If we want a 1 hour TWAP, we need to <strong>anticipate</strong> that we will need a snapshot of the accumulator one hour from now. So we need to access the public variable <code>price0CumulativeLast</code> and the public function <code>getReserves()</code> to get the last update time, and snapshot those values<p>After at least 1 hour has passed, we can call <code>getOneHourPrice()</code> and we will access the newest value of <code>price0CumulativeLast</code> from Uniswap V2.<p>Since the time we snapshotted the old price, <strong>Uniswap has been updating the accumulator.</strong><p><strong>We need to deploy a seperate contract that snapshots the cumulative prices of Uniswap to get the price for the interval of time that we want.</strong><p><strong>The following contrac is an example contract that calculates the average TWAP price of Token0 of a pool.</strong><ul><li><p>The <code>getOneHourPrice()</code> needs to be called atlease after an hour of time passed afer calling <code>snapshot()</code></p><li><p><code>getOneHourPrice()</code> can calculate price for not only just one hour, it can call for any time interval of (1 - 3) hours.</p></ul><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_12.webp><h3 id=what-if-the-last-snapshot-is-over-three-hours-ago><a aria-label="Anchor link for: what-if-the-last-snapshot-is-over-three-hours-ago" class=zola-anchor href=#what-if-the-last-snapshot-is-over-three-hours-ago><strong>What if the last snapshot is over three hours ago?</strong></a></h3><p>The <strong>above contract will fail</strong> to give price when there is a case that <code>update()</code> function has no been called for over 3 hours .<p>Uniswap V2 function <code>**_update**</code> is called during <strong>mint, burn, and swap</strong>, but <strong>none</strong> of those interactions <strong>happen</strong>, then <strong><code>lastSnapshotTime</code></strong> will record a time from a while ago.<p>In result the the <code>getTimeElapsed()</code> will return time which is greater than 3 hours. So, the <code>getOneHourPrice()</code> will be reverted due the check of second <code>require</code>.<p>So, to <strong>solve</strong> this problem <strong>call the sync function at the time it does a snapshot, as that will internally call _update.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_13.webp><h2 id=why-twap-must-track-two-ratios><a aria-label="Anchor link for: why-twap-must-track-two-ratios" class=zola-anchor href=#why-twap-must-track-two-ratios><strong>Why TWAP must track two ratios</strong></a></h2><p>The price of A with respect to B is simply A/B and vice versa. For example, if we have 2000 USDC in the pool (ignoring decimals), and 1 Ether, then the price of 1 Ether is simply 2000 USDC / 1 ETH.<p>The price of USDC, denominated in ETH, is simply that number with the numerator and denominator flipped.<p>However, we <strong>cannot</strong> just “<strong>invert</strong>” one of the prices to get the other when we are accumulating pricing. Consider the following. If our price accumulator starts at 2 and adds 3, we cannot just do one over the accumulator:</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter7_14.webp><p>However, the prices are still “somewhat symmetric,” hence the choice of fixed point arithmetic representation must have the same capacity for the integers and for the decimals. If Eth is 1,000 times more “valuable” than a USDC, then USDC is 1,000 times “less valuable” than USDC. To store this accurately, the fixed point number should have the same size on both sides of the decimal, hence Uniswap’s choice of <strong>u112x112</strong>.<h2 id=pricecumulativelast-always-increases-until-it-overflows-then-keeps-going><a aria-label="Anchor link for: pricecumulativelast-always-increases-until-it-overflows-then-keeps-going" class=zola-anchor href=#pricecumulativelast-always-increases-until-it-overflows-then-keeps-going><strong>PriceCumulativeLast always increases until it overflows, then keeps going</strong></a></h2><p><strong>Reason why Overflow desirable</strong><p>Uniswap V2 was built before Solidity 0.8.0, thus arithmetic overflowed and underflowed by default. Correct modern implementations of the price oracle need to use the <strong><code>unchecked</code></strong> block to ensure everything overflows as expected.<p>Eventually, the priceAccumulators and the block timestamp will overflow. In that case, the previous reserve will be higher than the new reserve. When the oracle computes the change in price, they will get a negative value. However, this won’t matter due to the rules of modular arithmetic.<p>To make things simple let’s use an imaginary unsigned integers that overflow at 100.<p>We snapshot the priceAccumulator at 80 and a few transactions/blocks later the priceAccumulator goes to 110, but it overflows to 10. We subtract 80 from 10, which gives -70. But the value is stored as an unsigned integer, so it gives -70 mod(100) which is 30. That’s the same result we would expect if it didn’t overflow (110-80=30).<p>This is true of all overflow boundaries, not just 100 in our example.<p>Overflowing the timestamp or priceAccumulator does not cause issues because of how modular arithmetic works.<h3 id=overflowing-the-timestamp><a aria-label="Anchor link for: overflowing-the-timestamp" class=zola-anchor href=#overflowing-the-timestamp>Overflowing the timestamp</a></h3><p>The same thing happens when we overflow the timestamp. Because we are using a uint32 to represent it, there won’t be any negative numbers. Again, let’s assume we overflow at 100 for the sake of simplicity. If we snapshot at time 98 and consult the price oracle at time 4, then 6 seconds have passed. 4 - 98 % 100 = 6, as expected.<h1 id=chapter-8-uniswapv2library><a aria-label="Anchor link for: chapter-8-uniswapv2library" class=zola-anchor href=#chapter-8-uniswapv2library><strong>Chapter - 8 : UniswapV2Library</strong></a></h1><p><em><strong>UniswapV2Library Code Walkthrough</strong></em><p>The <a href=https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol><strong>Uniswap V2 Library</strong></a> simplifies some interactions with pair contracts and is used heavily by the Router contracts. It contains eight functions that are <strong>not state-changing</strong>,. They are also handy for <strong>integrating Uniswap V2</strong> from a smart contract.<h2 id=using-uniswapv2library><a aria-label="Anchor link for: using-uniswapv2library" class=zola-anchor href=#using-uniswapv2library>Using UniswapV2Library</a></h2><p>If you want to predict how much to put into or expect out of a trade, or a sequence of trades across pairs, the UniswapV2Library is the tool to<h2 id=getamountout><a aria-label="Anchor link for: getamountout" class=zola-anchor href=#getamountout><strong>getAmountOut()</strong></a></h2><p><strong>Given an <em>input</em> asset amount, returns the maximum <em>output</em> amount of the other asset (accounting for fees) given reserves.</strong><p>Let <strong>x</strong> be the incoming token, <strong>y</strong> be the outgoing token, <code>Δx</code> be the amount coming in and <code>Δy</code> be the amount going out.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_1.webp><p><code>Δx</code> = <code>amountIn</code>* <code>0.997</code> (with 0.3% fee on in coming tokens)<h2 id=getamountin><a aria-label="Anchor link for: getamountin" class=zola-anchor href=#getamountin><strong>getAmountIn()</strong></a></h2><p><strong>Returns the minimum input asset amount required to buy the given output asset amount (accounting for fees) given reserves.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_2.jpg><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_3.webp><h2 id=pairfor-and-sorttokens><a aria-label="Anchor link for: pairfor-and-sorttokens" class=zola-anchor href=#pairfor-and-sorttokens>pairFor() and <strong><strong>sortTokens()</strong></strong></a></h2><p><strong><code>pairFor()</code> Calculates the address for a pair without making any external calls. It deterministically derived from the addresses of the tokens and the address of the factory that deployed the pair using the create2 function.</strong><p><strong><code>sortTokens()</code> sorts the order of tokens.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_4.webp><h2 id=getamountsout><a aria-label="Anchor link for: getamountsout" class=zola-anchor href=#getamountsout>getAmountsOut</a></h2><p>If a trader supplies a sequence of pairs, (A, B), (B, C), (C, D) and iteratively calls <strong>getAmountOut</strong> starting with a certain amount of A, then the amount of token D that will be received can be predicted.<ul><li>The smart contract doesn’t figure out the optimal sequence of pairs on its own, it needs to be told the list of pairs to calculate the chain of swaps over. This is best done off-chain.<li><strong>It doesn’t just return the final token amountOut in the chain, but the amount out at every step</strong>.</ul><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_5.png><h2 id=getamountsin><a aria-label="Anchor link for: getamountsin" class=zola-anchor href=#getamountsin>getAmountsIn</a></h2><p>Does opposite to <code>getAmountsOut</code></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_6.png><h2 id=getreserves><a aria-label="Anchor link for: getreserves" class=zola-anchor href=#getreserves><strong>getReserves()</strong></a></h2><p>The function getReserves is simply a wrapper around the function <strong>getReserves from the Uniswap V2 pair</strong> contract except that it also removes the timestamp when the price was last updated.<p>Calls <code>getReserves</code> on the pair for the passed tokens, and returns the results sorted <strong>in the order that the parameters were passed in</strong>.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_7.webp><h2 id=quote><a aria-label="Anchor link for: quote" class=zola-anchor href=#quote>quote()</a></h2><p><strong>Given some asset amount and reserves, returns an amount of the other asset representing equivalent value.</strong><p>This function returns the price of foo denominated in bar as of the last update. <strong>This function should be used with care as it is vulnerable to flash loan attacks.</strong></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_8.webp><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter8_9.webp><h1 id=chapter-9-routers><a aria-label="Anchor link for: chapter-9-routers" class=zola-anchor href=#chapter-9-routers><strong>Chapter - 9 : Routers</strong></a></h1><p><em><strong>Uniswap v2 router code walkthrough</strong></em><p>The Router contracts provide a user-facing smart contract for<ul><li><p>safely minting and burning LP tokens (adding and removing liquidity)</p><li><p>safely swapping pair tokens</p><li><p>They add the ability to swap Ether by integrating with the wrapped Ether (WETH) ERC20 contract.</p><li><p>They add the slippage related <strong>safety checks</strong> omitted from the core contract.</p><li><p>They add support for fee on transfer tokens.</p></ul><p><strong>Router contracts part of v2-periphery contracts.</strong><p><strong>Router02 is everything Router01 does with support added for fee on transfer tokens</strong><p>**UniswapV2Router01 should not be used any longer, because of the discovery of a <a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#getamountin>low severity bug</a> and the fact that some methods do not work with tokens that take fees on transfer.<p>The current recommendation is to use <a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02>UniswapV2Router02</a>.**<h2 id=uniswapv2router01><a aria-label="Anchor link for: uniswapv2router01" class=zola-anchor href=#uniswapv2router01>UniswapV2Router01</a></h2><p><code>[UniswapV2Router01](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router01.sol)</code> is deployed at <code>0xf164fC0Ec4E93095b804a4795bBe1e041497b92a</code> on the Ethereum <a href=https://etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a>mainnet</a>, and the <a href=https://ropsten.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a>Ropsten</a>, <a href=https://rinkeby.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a>Rinkeby</a>, <a href=https://goerli.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a>Görli</a>, and <a href=https://kovan.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a>Kovan</a> testnets. It was built from commit <a href=https://github.com/Uniswap/uniswap-v2-periphery/tree/2ad7da28a6f70ec4299364bc1608af8f30e7646b>2ad7da2</a>.<p><strong>Functions:</strong><ol><li><p>swapExactTokensForTokens()</p><li><p>swapTokensForExactTokens()</p><li><p>swapExactETHForTokens()</p><li><p>swapTokensForExactETH()</p><li><p>swapExactTokensForETH()</p><li><p>swapETHForExactTokens()</p><li><p>_swap()</p><li><p>_addLiquidity()</p><li><p>addLiquidity()</p><li><p>addLiquidityETH()</p><li><p>removeLiquidity()</p><li><p>removeLiquidityETH()</p><li><p>removeLiquidityWithPermit()</p><li><p>removeLiquidityETHWithPermit()</p><li><p>Read only functions : factory(), WETH()</p><li><p>UniswapV2Library functions</p></ol><h3 id=swapexacttokensfortokens><a aria-label="Anchor link for: swapexacttokensfortokens" class=zola-anchor href=#swapexacttokensfortokens><strong><a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#swapexacttokensfortokens>swapExactTokensForTokens()</a></strong></a></h3><p>In <strong><code>swapExactTokensForTokens</code></strong> the "<strong>first token is exact</strong>" means that the amount of the <strong>input</strong> token you are swapping is a <strong>fixed</strong> quantity.<p>The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).<p>In the case of swap<strong>Exact</strong>TokensForTokens, <strong>the user specifies exactly how much of the first token they are going to deposit and the minimum amount of the output token they will accept</strong>.<p><strong>For example</strong>, suppose we want to trade 25 token0 for 50 token1. If this is the exact price at the current state, this leaves no tolerance for the price changing before our transaction is confirmed, leading to a revert. So we instead specify the minimum out to be 49.5 token1, implicitly leaving a 1% tolerance.<p><code>**msg.sender</code> should have already given the router an allowance of at least amountIn on the input token.**<h3 id=swaptokensforexacttokens><a aria-label="Anchor link for: swaptokensforexacttokens" class=zola-anchor href=#swaptokensforexacttokens><a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#swaptokensforexacttokens>swapTokensForExactTokens()</a></a></h3><p>In <strong><code>swapTokensForExactTokens</code></strong>, the <strong>"second token is exact"</strong> indicates that the amount of the <strong>output</strong> token you want to receive is a <strong>fixed</strong> quantity.<p>In this case we specify we want exactly 50 token1, but we are willing to trade up to 25.5 token0 to obtain in.<p>Receive an <strong>exact</strong> amount of <strong>output</strong> tokens for as few input tokens as possible, along the route determined by the path.<p><code>**msg.sender</code> should have already given the router an allowance of at least amountInMax on the input token.**<h3 id=which-swap-function-to-use><a aria-label="Anchor link for: which-swap-function-to-use" class=zola-anchor href=#which-swap-function-to-use><strong>Which swap function to use?</strong></a></h3><p>Users using <strong>EOA</strong> will use <strong><code>swapExactTokensForTokens</code></strong> function. Because they can approve the exact amount of tokens that going to send. And the approve will revert when they dont receive specified minimum amount of tokens. <strong>By having an exact input, they can approve the exact amount.</strong><p><strong>Smart contracts integrating with Uniswap</strong> however may have more complex requirements, so the router gives them the <strong>option for both.</strong><h3 id=how-swap-works><a aria-label="Anchor link for: how-swap-works" class=zola-anchor href=#how-swap-works>How swap works?</a></h3><p>When the input is exact (<strong>swapExactTokensForTokens</strong>), the function predicts the expected output across a single swap or a chain of swaps. If the resulting output is below the user specified amount, the function reverts. Vice versa for exact output: it calculates the required input and reverts if it is above the user specified threshold.<p>Then <strong>both functions will transfer the user’s tokens to the pair</strong> (remember, Uniswap V2 Pair requires the tokens to be sent into the contract before the pair contract function swap is called). Finally, they both call the internal <strong>_swap</strong> function discussed next.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_1.webp><h2 id=the-swap-function><a aria-label="Anchor link for: the-swap-function" class=zola-anchor href=#the-swap-function>The _swap() function</a></h2><p>Under the hood, all publicly facing functions with the name <strong>swap</strong> in the name call the <strong>_swap</strong> internal function shown below.<p>Recall that the function signature for the core <a href=https://www.rareskills.io/post/uniswap-v2-swap-function><strong>swap function</strong></a> specifies the <strong>amountOut</strong> for both tokens and the <strong>amountIn</strong> is implied by the amount that was transferred in before the function was called.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_2.webp><p>The <code>new bytes(0)</code> parameter means not to do a flashswap, which is usually executed when performing a canonical swap.<h3 id=swapexactethfortokens><a aria-label="Anchor link for: swapexactethfortokens" class=zola-anchor href=#swapexactethfortokens><strong><a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#swapexactethfortokens>swapExactETHForTokens</a></strong></a></h3><p>Swaps an <strong>exact amount of ETH for as many output tokens as possible</strong>, along the route determined by the path. <strong>The first element of path must be <a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#weth>WETH</a>,</strong> the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_3.png><h3 id=swaptokensforexacteth><a aria-label="Anchor link for: swaptokensforexacteth" class=zola-anchor href=#swaptokensforexacteth><strong><a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#swaptokensforexacteth>swapTokensForExactETH</a></strong></a></h3><p><strong>Receive an exact amount of ETH</strong> for as few input tokens as possible, along the route determined by the path. The first element of path is the input token, <strong>the last must be <a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#weth>WETH</a></strong>, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).<ul><li><p><code>msg.sender</code> should have already given the router an allowance of at least amountInMax on the input token.</p><li><p>If the to address is a smart contract, it must have the ability to receive ETH.</p></ul><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_4.png><h3 id=swapexacttokensforeth><a aria-label="Anchor link for: swapexacttokensforeth" class=zola-anchor href=#swapexacttokensforeth><strong><a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#swapexacttokensforeth>swapExactTokensForETH</a></strong></a></h3><p>Swaps an <strong>exact amount of tokens</strong> for as much ETH as possible, along the route determined by the path. The first element of path is the input token, <strong>the last must be <a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#weth>WETH</a>,</strong> and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).<ul><li>If the to address is a smart contract, it must have the ability to receive ETH.</ul><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_5.png><h3 id=swapethforexacttokens><a aria-label="Anchor link for: swapethforexacttokens" class=zola-anchor href=#swapethforexacttokens><strong><a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#swapethforexacttokens>swapETHForExactTokens</a></strong></a></h3><p><strong>Receive an exact amount of tokens</strong> for as little ETH as possible, along the route determined by the path. The <strong>first element of path must be <a href=https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01#weth>WETH</a></strong>, the <strong>last is the output token</strong> and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).<ul><li>Leftover ETH, if any, is returned to <code>msg.sender</code>.</ul><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_6.png><h3 id=addliquidity><a aria-label="Anchor link for: addliquidity" class=zola-anchor href=#addliquidity><strong>_addLiquidity</strong></a></h3><p><strong>Safety checks for adding liquidity</strong> Specifically, <strong>we want to make sure we deposit the two tokens at exactly the same ratio as what the pair currently has</strong>, otherwise the amount of LP tokens we mint is the worse of the two ratios between what we provide and what the pair balances are. However, the ratio could change between when the liquidity provider attempts to add liquidity and when the transaction is confirmed.<p><strong>To guard against this</strong>, a liquidity provider must provide (as a parameter), the minimum balance they are seeking to deposit for token0 and token1 (UniswapV2 calls those <strong>amountAMin</strong> and <strong>amountBMin</strong>). Then they transfer in an amount higher than those minimums (UnsiwapV2 calls those <strong>amountADesired</strong> and <strong>amountBDesired</strong>). If the pair ratio has shifted in such a way that the minimums are no longer respected, then the transaction reverts.<p><strong>_addLiquidity</strong> will take <strong>amountADesired</strong> and calculate the correct amount of tokenB that will respect the ratio. If this is amount is higher than <strong>amountBDesired</strong> (the amount of B the liquidity provider sent), then it will start with <strong>amountBDesired</strong> and calculate the optimal amount of B. The logic is show below. Note that adding liquidity may create a new pair contract if it doesn’t already exist.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_7.webp><p>For example, suppose the current pair balance is 100 token0 and 300 token1. We want to add 20 and 60 token0 and token1 respectively, but the pair ratio might change. So we instead approve the router for 21 token0 and 63 token1 while saying the minimum we want to deposit is 20 and 60. If the ratio shifts such that the optimal amount of token0 to deposit is 19.9, then the transaction reverts.<p>Recall that we said <strong>quote</strong> should not be used as an <strong>oracle</strong>, and that is still true. However for the purposes of adding liquidity we are not interested in the average of previous prices but the current price (pool ratio) now because the liquidity provider must respect it.<h3 id=addliquidity-and-addliquidityeth><a aria-label="Anchor link for: addliquidity-and-addliquidityeth" class=zola-anchor href=#addliquidity-and-addliquidityeth><strong>addLiquidity() and addLiquidityEth()</strong></a></h3><p>These functions should be self-explanatory. They first calculate the optimal ratio using <strong>_addLiquidity</strong> from above then transfer the assets to the pair, then call mint on the pair. The only difference is the <code>**addLiquidityEth**</code> function will wrap the Ether into WETH first.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_8.webp><h3 id=removing-liquidity><a aria-label="Anchor link for: removing-liquidity" class=zola-anchor href=#removing-liquidity><strong>Removing Liquidity</strong></a></h3><p>Remove liquidity calls burn but uses parameters <strong>amountAMin</strong> and <strong>amountBMin</strong> (red highlights) as <strong>safety checks</strong> to ensure that the liquidity provider gets back the amount of tokens they are expecting. If the ratio of tokens changes dramatically before the the liquidity tokens are burned, then the user burning the tokens won’t get back the amount of token A or B that they are expecting.<p>The function <strong>removeLiquidityEth</strong> calls <strong>removeLiquidity</strong> (green highlight) but sets the router as the recipient of the tokens. The regular ERC20 token is then transferred to the liquidity provider, and the WETH is unwrapped to ETH, then sent back to the liquidity provider.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_9.webp><h3 id=removeliquiditywithpermit-and-removeliquidityethwithpermit><a aria-label="Anchor link for: removeliquiditywithpermit-and-removeliquidityethwithpermit" class=zola-anchor href=#removeliquiditywithpermit-and-removeliquidityethwithpermit>removeLiquidityWithPermit() and removeLiquidityETHWithPermit()</a></h3><p>On line 109 in the file above with the gray comment send liquidity to pair, this step assumes the pair contract has approval to transfer LP tokens from the liquidity provider to burn them. This means burning the LP tokens requires approving the pair first. This step can be skipped with <strong>permit()</strong>, since the LP tokens of Uniswap V2 is an <a href=https://eips.ethereum.org/EIPS/eip-2612>ERC20 Permit Token</a>. The function <strong>removeLiquidityWithPermit()</strong> receives a signature to approve and burn in one transaction. If one of the tokens is WETH, the liquidity provider would use <strong>removeLiquidityETHWithPermit()</strong>.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_10.png><h2 id=uniswapv2router02><a aria-label="Anchor link for: uniswapv2router02" class=zola-anchor href=#uniswapv2router02>UniswapV2Router02</a></h2><p>Because routers are stateless and do not hold token balances, they can be replaced safely and trustlessly, if necessary. This may happen if more efficient smart contract patterns are discovered, or if additional functionality is desired. For this reason, routers have <em>release numbers</em>, starting at <code>01</code>. This is currently recommended release, <code>02</code>.<p><code>UniswapV2Router02</code> is deployed at <code>0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D</code> on the Ethereum <a href=https://etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D>mainnet</a>, and the <a href=https://ropsten.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D>Ropsten</a>, <a href=https://rinkeby.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D>Rinkeby</a>, <a href=https://goerli.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D>Görli</a>, and <a href=https://kovan.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D>Kovan</a> testnets. It was built from commit <a href=https://github.com/Uniswap/uniswap-v2-periphery/tree/69617118cda519dab608898d62aaa79877a61004>6961711</a>.<p><em><strong>Router02 : supporting fee on transfer tokens (tokens will take fees when any transfer of the token is performed).</strong></em><p>To handle fee on transfer tokens, the router cannot directly do it’s calculations on arguments like <strong>amountIn</strong> (for swap) or <strong>liquidity</strong> (for removing liquidity). <strong>Adding liquidity is not affected by fee on transfer tokens because the user is only credited for what they actually transfer to the pair.</strong><p><strong>Functions:</strong><p>Router1 + some extra.<ol><li><p>_swapSupportingFeeOnTransferTokens()</p><li><p>swapExactTokensForTokensSupportingFeeOnTransferTokens()</p><li><p>swapExactETHForTokensSupportingFeeOnTransferTokens()</p><li><p>swapExactTokensForETHSupportingFeeOnTransferTokens()</p><li><p>removeLiquidityETHSupportingFeeOnTransferTokens()</p><li><p>removeLiquidityETHWithPermitSupportingFeeOnTransferTokens()</p></ol><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_11.webp><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_12.webp><h3 id=wrappers-around-the-uniswapv2library><a aria-label="Anchor link for: wrappers-around-the-uniswapv2library" class=zola-anchor href=#wrappers-around-the-uniswapv2library><strong>Wrappers around the UniswapV2Library</strong></a></h3><p>The rest of the functions in the Router library are wrappers around the <a href=https://www.rareskills.io/post/uniswap-v2-library>UniswapV2Library</a> functions as shown below.</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter9_13.webp><h2 id=summary><a aria-label="Anchor link for: summary" class=zola-anchor href=#summary>Summary</a></h2><p>The Router contracts provide a user-facing mechanism for swapping tokens with slippage protection, possibly across multiple pools, and add support for trading ETH and fee-on-transfer tokens (in Router02). Depositing liquidity does not need to account for fee-on-transfer tokens because Uniswap only credits for what was actually transferred into the pool.<p>The depositing liquidity functions ensure the user only deposits at the exact ratio of the pool. Removing liquidity can be as simple as transferring LP tokens to the router then burning them, or include unwrapping WETH and withdrawing fee on transfer tokens.<h1 id=chapter-10-misc><a aria-label="Anchor link for: chapter-10-misc" class=zola-anchor href=#chapter-10-misc><strong>Chapter - 10 : MISC</strong></a></h1><h1 id=uniswapv2factory-sol><a aria-label="Anchor link for: uniswapv2factory-sol" class=zola-anchor href=#uniswapv2factory-sol>UniswapV2Factory.sol</a></h1><p><strong>The factory contract is mainly responsible for creating new contract pairs</strong> (<strong>UniswapV2Pair</strong>.<strong>sol</strong>).<p>In order to concentrate liquidity, there can only be one smart contract per pair. In other words, if there is a WETH/UNI pair contract already, the factory won’t allow you to create the same pair. Of course, you can bypass that (by deploying the pair contract directly), but the core principle here is to concentrate liquidity as much as possible to avoid price slippage and have more liquidity.<p>Here is the function that creates pairs in UniswapV2Factory:</p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter10_1.webp><h1 id=uniswapv2migrator-sol><a aria-label="Anchor link for: uniswapv2migrator-sol" class=zola-anchor href=#uniswapv2migrator-sol><strong>UniswapV2Migrator.sol</strong></a></h1><ul><li><p>Migrate liquidity from UniswapV1</p><li><p>In order to transfer all the liquidity that was in Uniswap V1, they automatically withdrew and deposited in uniswap v2. But there has been a lot of Rug-pull?</p> <ul><li>My LP, because I handed over my authority, my entire property was hit by users whose credit was not guaranteed. In the end, malicious users tend to steal money and then launder it.</ul><li><p>Migration itself makes it easy to transfer liquidity, and it is difficult to change on the blockchain because it is difficult to transfer existing customers.</p></ul><h1 id=uniswapv2erc20-sol><a aria-label="Anchor link for: uniswapv2erc20-sol" class=zola-anchor href=#uniswapv2erc20-sol><strong>UniswapV2ERC20.sol</strong></a></h1><ul><li><p>Used for defining LP token.</p><li><p>ERC20 wrap to EIP712 for using permit function</p></ul><h1 id=uniswapv2pair-sol-sync-and-skim><a aria-label="Anchor link for: uniswapv2pair-sol-sync-and-skim" class=zola-anchor href=#uniswapv2pair-sol-sync-and-skim><strong>UniswapV2Pair.sol : sync() and skim()</strong></a></h1><p><strong>skim</strong> and <strong>sync</strong> are needed when balances on the ERC20 contracts of the exchange tokens, fall out of sync with the reserve variables in the Pair contract. This can happen for example when someone just transfers some Dogecoin to Pair contract’s account for no reason. There are 2 solutions to keep reserve variables in sync with the actual balances on ERC20 contracts.<p>When liquidity is added in Uniswap v2 the reserves are updated. However, in a case where tokens are deposited in contract, the balance of the contract would vary from the amount of reserves. The trade performed while balances and reserves are not synced would have incorrect values. The function <strong><code>sync()</code></strong> sets the reserves of the contract according to the balances.<p><em>sync() functions as a recovery mechanism in the case that a token asynchronously deflates the balance of a pair. In this case, trades will receive sub-optimal rates, and if no liquidity provider is willing to rectify the situation, the pair is stuck. sync() exists to set the reserves of the contract to the current balances, providing a somewhat graceful recovery from this situation.</em></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter10_2.png><p>If the user deposits balance in the contract and this balance exceeds uint112. Calling the <code>**sync**()</code> function is not suitable. Since the **<code>_update**()</code> function in **<code>sync**()</code> uses uint112 which will overflow. In such a case the function **<code>skim**()</code> is to be used. Skim will remove the excess balance and resolve the deadlock of clogging the <strong>uint112</strong>.<p><em>skim() functions as a recovery mechanism in case enough tokens are sent to an pair to overflow the two uint112 storage slots for reserves, which could otherwise cause trades to fail. skim() allows a user to withdraw the difference between the current balance of the pair and <code>2**112 - 1</code> to the caller, if that difference is greater than 0.</em></p><img src=/assets/img/blog_img/uniswap-v2-complete/u2_chapter10_3.png><ul><li><p>It allows someone to withdraw the extra funds from the Pair contract. Anyone can call this function!</p><li><p>The skim() function forces the balances to match reserves</p><li><p>it transfers any extra token to the address that called the function</p></ul><h2 id=references><a aria-label="Anchor link for: references" class=zola-anchor href=#references>References</a></h2><ul><li><a href=https://www.rareskills.io/uniswap-v2-book target=_blank>Rareskills Uniswap V2 Book</a><li><a href=https://twitter.com/0xOwenThurm/status/1662805937575596034 target=_blank>@0xOwneThurm AMM tutorial</a><li><a href=https://twitter.com/ProgrammerSmart target=_blank>@ProgrammerSmart</a><li><a href="https://mirror.xyz/zer0luck.eth/rnu5BTT8f45lq3YUlTBoADGOhI0zpfa710SinXaGoZ8?source=post_page-----e42fe275e13c--------------------------------" target=_blank>@Zer0luck.eth Blog</a><li><a href=https://blog.pessimistic.io/ target=_blank>@pessimistic_io Blogs</a><li><a href="https://blog.pessimistic.io/amm-automatic-market-makers-integration-tips-e42fe275e13c?source=collection_home---4------4-----------------------" target=_blank>AMM Integration tips by @officer_cia</a><li><a href=https://docs.uniswap.org/concepts/uniswap-protocol target=_blank>Uniswap Docs</a><li><a href=https://mirror.xyz/0x0cf5C6d3c1122504091EAd6a3Dc5BD31f7BbeDE3 taget=_blank>A Great Anon</a><li><a href=https://medium.com/coinmonks/uniswap-introduction-2-c60e66530e68 taget=_blank>An Eilte Anon</a><li><a href=https://github.com/casweeney/Uniswap-ALL-IN-ONE target=_blank>Great examples by a Ultimate guy</a></ul></section></article></main></div>